/*
 * Copyright (c) Institute for System Programming of the Russian Academy of Sciences
 * All Rights Reserved
 *
 * Institute for System Programming of the Russian Academy of Sciences (ISP RAS)
 * 25 Alexander Solzhenitsyn st., Moscow, 109004, Russia
 * http://www.ispras.ru
 *
 * The present file was automatically generated on the basis of formal specifications.
 * It is distributed under the same terms and conditions as the derived specifications.
 *
 * N.B. PLEASE DO NOT MODIFY THIS FILE.
 */

package ru.ispras.microtesk.model.minimips.mmu.sim;

import java.math.BigInteger;
import ru.ispras.microtesk.model.Execution;
import ru.ispras.microtesk.mmu.model.api.*;
import ru.ispras.fortress.data.types.bitvector.*;

/**
 * The {@code pmem} class is automatically generated by MicroTESK.
 *
 * @author <a href="mailto:microtesk-support@ispras.ru">MicroTESK</a>
 */
public final class pmem extends Mmu<VA> {
  private static pmem instance = null;

  public static pmem get() {
    if (null == instance) {
      instance = new pmem();
    }
    return instance;
  }

  private pmem() {}

  @Override
  public int getAddressBitSize() {
    return 32;
  }

  @Override
  public int getDataBitSize() {
    return 32;
  }

  @Override
  protected VA newAddress() {
    return new VA();
  }

  @Override
  public BitVector getData(final VA va) {
    final BitVector data = BitVector.newEmpty(32);

    final BitVector c = BitVector.newEmpty(3);
    final L1.Entry l1Entry = new L1.Entry();
    final L2.Entry l2Entry = new L2.Entry();
    final PA pa = new PA();
    final BitVector cacheData = BitVector.newEmpty(256);
    final BitVector offset = BitVector.newEmpty(3);

    c.assign(BitVector.valueOf(0x3, 3));
    pa.value.assign(va.value);
    MMU_PA.get().setData(pa).assign(pa.value);
    offset.assign(pa.value.field(4, 2));
    if (!c.field(1, 0).equals(BitVector.valueOf(0x2, 2))) {
      if (L1.get().isHit(pa)) {
        l1Entry.assign(L1.get().getData(pa));
        cacheData.assign(l1Entry.DATA);
        data.assign(readData.call(cacheData, offset));
      } else {
        if (c.field(1, 0).equals(BitVector.valueOf(0x3, 2))) {
          if (L2.get().isHit(pa)) {
            l2Entry.assign(L2.get().getData(pa));
            cacheData.assign(l2Entry.DATA);
            data.assign(readData.call(cacheData, offset));
            l1Entry.V.assign(BitVector.valueOf(0x1, 1));
            l1Entry.TAG.assign(pa.value.field(31, 12));
            l1Entry.DATA.assign(cacheData);
            L1.get().setData(pa).assign(l1Entry);
          } else {
            cacheData.assign(M.get().getData(pa).asBitVector());
            data.assign(readData.call(cacheData, offset));
            l2Entry.V.assign(BitVector.valueOf(0x1, 1));
            l2Entry.TAG.assign(pa.value.field(31, 17));
            l2Entry.DATA.assign(cacheData);
            L2.get().setData(pa).assign(l2Entry);
            l1Entry.V.assign(BitVector.valueOf(0x1, 1));
            l1Entry.TAG.assign(pa.value.field(31, 12));
            l1Entry.DATA.assign(cacheData);
            L1.get().setData(pa).assign(l1Entry);
          }
        } else {
          cacheData.assign(M.get().getData(pa).asBitVector());
          data.assign(readData.call(cacheData, offset));
          l1Entry.V.assign(BitVector.valueOf(0x1, 1));
          l1Entry.TAG.assign(pa.value.field(31, 12));
          l1Entry.DATA.assign(cacheData);
          L1.get().setData(pa).assign(l1Entry);
        }
      }
    } else {
      cacheData.assign(M.get().getData(pa).asBitVector());
      data.assign(readData.call(cacheData, offset));
    }

    return data;
  }

  @Override
  public BitVector setData(final VA va, final BitVector data) {
    final BitVector c = BitVector.newEmpty(3);
    final L1.Entry l1Entry = new L1.Entry();
    final L2.Entry l2Entry = new L2.Entry();
    final PA pa = new PA();
    final BitVector cacheData = BitVector.newEmpty(256);
    final BitVector offset = BitVector.newEmpty(3);

    c.assign(BitVector.valueOf(0x3, 3));
    pa.value.assign(va.value);
    offset.assign(pa.value.field(4, 2));
    if (!c.field(1, 0).equals(BitVector.valueOf(0x2, 2))) {
      if (L1.get().isHit(pa)) {
        l1Entry.assign(L1.get().getData(pa));
        writeData.call(l1Entry.DATA, offset, data);
        L1.get().setData(pa).assign(l1Entry);
        M.get().setData(pa).assign(l1Entry.DATA);
      } else {
        if (c.field(1, 0).equals(BitVector.valueOf(0x3, 2))) {
          if (L2.get().isHit(pa)) {
            l2Entry.assign(L2.get().getData(pa));
            writeData.call(l2Entry.DATA, offset, data);
            L2.get().setData(pa).assign(l2Entry);
            l1Entry.V.assign(BitVector.valueOf(0x1, 1));
            l1Entry.TAG.assign(pa.value.field(31, 12));
            l1Entry.DATA.assign(l2Entry.DATA);
            L1.get().setData(pa).assign(l1Entry);
            M.get().setData(pa).assign(l1Entry.DATA);
          } else {
            cacheData.assign(M.get().getData(pa).asBitVector());
            writeData.call(cacheData, offset, data);
            M.get().setData(pa).assign(cacheData);
            l2Entry.V.assign(BitVector.valueOf(0x1, 1));
            l2Entry.TAG.assign(pa.value.field(31, 17));
            l2Entry.DATA.assign(cacheData);
            L2.get().setData(pa).assign(l2Entry);
            l1Entry.V.assign(BitVector.valueOf(0x1, 1));
            l1Entry.TAG.assign(pa.value.field(31, 12));
            l1Entry.DATA.assign(cacheData);
            L1.get().setData(pa).assign(l1Entry);
          }
        } else {
          cacheData.assign(M.get().getData(pa).asBitVector());
          writeData.call(cacheData, offset, data);
          M.get().setData(pa).assign(cacheData);
          l1Entry.V.assign(BitVector.valueOf(0x1, 1));
          l1Entry.TAG.assign(pa.value.field(31, 12));
          l1Entry.DATA.assign(cacheData);
          L1.get().setData(pa).assign(l1Entry);
        }
      }
    } else {
      cacheData.assign(M.get().getData(pa).asBitVector());
      writeData.call(cacheData, offset, data);
      M.get().setData(pa).assign(cacheData);
    }

    return null;
  }
}

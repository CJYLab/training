/*
 * Copyright (c) Institute for System Programming of the Russian Academy of Sciences
 * All Rights Reserved
 *
 * Institute for System Programming of the Russian Academy of Sciences (ISP RAS)
 * 25 Alexander Solzhenitsyn st., Moscow, 109004, Russia
 * http://www.ispras.ru
 *
 * The present file was automatically generated on the basis of formal specifications.
 * It is distributed under the same terms and conditions as the derived specifications.
 *
 * N.B. PLEASE DO NOT MODIFY THIS FILE.
 */

package ru.ispras.microtesk.model.x86;

import java.math.BigInteger;
import ru.ispras.microtesk.model.ProcessingElement;
import ru.ispras.microtesk.model.data.Type;
import ru.ispras.microtesk.model.memory.Label;
import ru.ispras.microtesk.model.memory.Memory;

/**
 * The {@code PE} class is automatically generated by MicroTESK.
 *
 * @author <a href="mailto:microtesk-support@ispras.ru">MicroTESK</a>
 */
public final class PE extends ProcessingElement {
  public final Memory program_counter;
  public final Memory GPR;
  public final Memory AX;
  public final Memory AL;
  public final Memory AH;
  public final Memory CX;
  public final Memory CL;
  public final Memory CH;
  public final Memory DX;
  public final Memory DL;
  public final Memory DH;
  public final Memory BX;
  public final Memory BL;
  public final Memory BH;
  public final Memory SP;
  public final Memory BP;
  public final Memory SI;
  public final Memory DI;
  public final Memory RSEG;
  public final Memory ES;
  public final Memory CS;
  public final Memory SS;
  public final Memory DS;
  public final Memory IP;
  public final Memory FLAGS;
  public final Memory CF;
  public final Memory PF;
  public final Memory AF;
  public final Memory ZF;
  public final Memory SF;
  public final Memory TF;
  public final Memory IF;
  public final Memory DF;
  public final Memory OF;
  public final Memory MEM;
  public final Memory BRANCH;
  public final Memory NEXTPC;

  private PE() {
    super();
    this.program_counter = Memory.def(Memory.Kind.REG, "program_counter", TypeDefs.addR, 1);
    this.GPR = Memory.def(Memory.Kind.REG, "GPR", TypeDefs.WORD, 8);
    this.AX = Memory.def(Memory.Kind.REG, "AX", TypeDefs.WORD, 1, GPR.access(0));
    this.AL = Memory.def(Memory.Kind.REG, "AL", TypeDefs.BYTE, 1, AX.access().bitField(7, 0));
    this.AH = Memory.def(Memory.Kind.REG, "AH", TypeDefs.BYTE, 1, AX.access().bitField(15, 8));
    this.CX = Memory.def(Memory.Kind.REG, "CX", TypeDefs.WORD, 1, GPR.access(1));
    this.CL = Memory.def(Memory.Kind.REG, "CL", TypeDefs.BYTE, 1, CX.access().bitField(7, 0));
    this.CH = Memory.def(Memory.Kind.REG, "CH", TypeDefs.BYTE, 1, CX.access().bitField(15, 8));
    this.DX = Memory.def(Memory.Kind.REG, "DX", TypeDefs.WORD, 1, GPR.access(2));
    this.DL = Memory.def(Memory.Kind.REG, "DL", TypeDefs.BYTE, 1, DX.access().bitField(7, 0));
    this.DH = Memory.def(Memory.Kind.REG, "DH", TypeDefs.BYTE, 1, DX.access().bitField(15, 8));
    this.BX = Memory.def(Memory.Kind.REG, "BX", TypeDefs.WORD, 1, GPR.access(3));
    this.BL = Memory.def(Memory.Kind.REG, "BL", TypeDefs.BYTE, 1, BX.access().bitField(7, 0));
    this.BH = Memory.def(Memory.Kind.REG, "BH", TypeDefs.BYTE, 1, BX.access().bitField(15, 8));
    this.SP = Memory.def(Memory.Kind.REG, "SP", TypeDefs.WORD, 1, GPR.access(4));
    this.BP = Memory.def(Memory.Kind.REG, "BP", TypeDefs.WORD, 1, GPR.access(5));
    this.SI = Memory.def(Memory.Kind.REG, "SI", TypeDefs.WORD, 1, GPR.access(6));
    this.DI = Memory.def(Memory.Kind.REG, "DI", TypeDefs.WORD, 1, GPR.access(7));
    this.RSEG = Memory.def(Memory.Kind.REG, "RSEG", TypeDefs.WORD, 4);
    this.ES = Memory.def(Memory.Kind.REG, "ES", TypeDefs.WORD, 1, RSEG.access(0));
    this.CS = Memory.def(Memory.Kind.REG, "CS", TypeDefs.WORD, 1, RSEG.access(1));
    this.SS = Memory.def(Memory.Kind.REG, "SS", TypeDefs.WORD, 1, RSEG.access(2));
    this.DS = Memory.def(Memory.Kind.REG, "DS", TypeDefs.WORD, 1, RSEG.access(3));
    this.IP = Memory.def(Memory.Kind.REG, "IP", TypeDefs.WORD, 1);
    this.FLAGS = Memory.def(Memory.Kind.REG, "FLAGS", TypeDefs.WORD, 1);
    this.CF = Memory.def(Memory.Kind.REG, "CF", TypeDefs.BIT, 1, FLAGS.access().bitField(0, 0));
    this.PF = Memory.def(Memory.Kind.REG, "PF", TypeDefs.BIT, 1, FLAGS.access().bitField(2, 2));
    this.AF = Memory.def(Memory.Kind.REG, "AF", TypeDefs.BIT, 1, FLAGS.access().bitField(4, 4));
    this.ZF = Memory.def(Memory.Kind.REG, "ZF", TypeDefs.BIT, 1, FLAGS.access().bitField(6, 6));
    this.SF = Memory.def(Memory.Kind.REG, "SF", TypeDefs.BIT, 1, FLAGS.access().bitField(7, 7));
    this.TF = Memory.def(Memory.Kind.REG, "TF", TypeDefs.BIT, 1, FLAGS.access().bitField(8, 8));
    this.IF = Memory.def(Memory.Kind.REG, "IF", TypeDefs.BIT, 1, FLAGS.access().bitField(9, 9));
    this.DF = Memory.def(Memory.Kind.REG, "DF", TypeDefs.BIT, 1, FLAGS.access().bitField(10, 10));
    this.OF = Memory.def(Memory.Kind.REG, "OF", TypeDefs.BIT, 1, FLAGS.access().bitField(11, 11));
    this.MEM = Memory.def(Memory.Kind.MEM, "MEM", TypeDefs.BYTE, 0x100000);
    this.BRANCH = Memory.def(Memory.Kind.MEM, "BRANCH", TypeDefs.BIT, 1);
    this.NEXTPC = Memory.def(Memory.Kind.MEM, "NEXTPC", TypeDefs.WORD, 1);

    registerAll();
  }

  private PE(final PE other, final boolean shared) {
    super(other);
    this.program_counter = other.program_counter.copy();
    this.GPR = other.GPR.copy();
    this.AX = Memory.def(Memory.Kind.REG, "AX", TypeDefs.WORD, 1, GPR.access(0));
    this.AL = Memory.def(Memory.Kind.REG, "AL", TypeDefs.BYTE, 1, AX.access().bitField(7, 0));
    this.AH = Memory.def(Memory.Kind.REG, "AH", TypeDefs.BYTE, 1, AX.access().bitField(15, 8));
    this.CX = Memory.def(Memory.Kind.REG, "CX", TypeDefs.WORD, 1, GPR.access(1));
    this.CL = Memory.def(Memory.Kind.REG, "CL", TypeDefs.BYTE, 1, CX.access().bitField(7, 0));
    this.CH = Memory.def(Memory.Kind.REG, "CH", TypeDefs.BYTE, 1, CX.access().bitField(15, 8));
    this.DX = Memory.def(Memory.Kind.REG, "DX", TypeDefs.WORD, 1, GPR.access(2));
    this.DL = Memory.def(Memory.Kind.REG, "DL", TypeDefs.BYTE, 1, DX.access().bitField(7, 0));
    this.DH = Memory.def(Memory.Kind.REG, "DH", TypeDefs.BYTE, 1, DX.access().bitField(15, 8));
    this.BX = Memory.def(Memory.Kind.REG, "BX", TypeDefs.WORD, 1, GPR.access(3));
    this.BL = Memory.def(Memory.Kind.REG, "BL", TypeDefs.BYTE, 1, BX.access().bitField(7, 0));
    this.BH = Memory.def(Memory.Kind.REG, "BH", TypeDefs.BYTE, 1, BX.access().bitField(15, 8));
    this.SP = Memory.def(Memory.Kind.REG, "SP", TypeDefs.WORD, 1, GPR.access(4));
    this.BP = Memory.def(Memory.Kind.REG, "BP", TypeDefs.WORD, 1, GPR.access(5));
    this.SI = Memory.def(Memory.Kind.REG, "SI", TypeDefs.WORD, 1, GPR.access(6));
    this.DI = Memory.def(Memory.Kind.REG, "DI", TypeDefs.WORD, 1, GPR.access(7));
    this.RSEG = other.RSEG.copy();
    this.ES = Memory.def(Memory.Kind.REG, "ES", TypeDefs.WORD, 1, RSEG.access(0));
    this.CS = Memory.def(Memory.Kind.REG, "CS", TypeDefs.WORD, 1, RSEG.access(1));
    this.SS = Memory.def(Memory.Kind.REG, "SS", TypeDefs.WORD, 1, RSEG.access(2));
    this.DS = Memory.def(Memory.Kind.REG, "DS", TypeDefs.WORD, 1, RSEG.access(3));
    this.IP = other.IP.copy();
    this.FLAGS = other.FLAGS.copy();
    this.CF = Memory.def(Memory.Kind.REG, "CF", TypeDefs.BIT, 1, FLAGS.access().bitField(0, 0));
    this.PF = Memory.def(Memory.Kind.REG, "PF", TypeDefs.BIT, 1, FLAGS.access().bitField(2, 2));
    this.AF = Memory.def(Memory.Kind.REG, "AF", TypeDefs.BIT, 1, FLAGS.access().bitField(4, 4));
    this.ZF = Memory.def(Memory.Kind.REG, "ZF", TypeDefs.BIT, 1, FLAGS.access().bitField(6, 6));
    this.SF = Memory.def(Memory.Kind.REG, "SF", TypeDefs.BIT, 1, FLAGS.access().bitField(7, 7));
    this.TF = Memory.def(Memory.Kind.REG, "TF", TypeDefs.BIT, 1, FLAGS.access().bitField(8, 8));
    this.IF = Memory.def(Memory.Kind.REG, "IF", TypeDefs.BIT, 1, FLAGS.access().bitField(9, 9));
    this.DF = Memory.def(Memory.Kind.REG, "DF", TypeDefs.BIT, 1, FLAGS.access().bitField(10, 10));
    this.OF = Memory.def(Memory.Kind.REG, "OF", TypeDefs.BIT, 1, FLAGS.access().bitField(11, 11));
    this.MEM = shared ? other.MEM : other.MEM.copy();
    this.BRANCH = other.BRANCH.copy();
    this.NEXTPC = other.NEXTPC.copy();

    registerAll();
  }

  private void registerAll() {
    addStorage(program_counter);
    addStorage(GPR);
    addStorage(AX);
    addStorage(AL);
    addStorage(AH);
    addStorage(CX);
    addStorage(CL);
    addStorage(CH);
    addStorage(DX);
    addStorage(DL);
    addStorage(DH);
    addStorage(BX);
    addStorage(BL);
    addStorage(BH);
    addStorage(SP);
    addStorage(BP);
    addStorage(SI);
    addStorage(DI);
    addStorage(RSEG);
    addStorage(ES);
    addStorage(CS);
    addStorage(SS);
    addStorage(DS);
    addStorage(IP);
    addStorage(FLAGS);
    addStorage(CF);
    addStorage(PF);
    addStorage(AF);
    addStorage(ZF);
    addStorage(SF);
    addStorage(TF);
    addStorage(IF);
    addStorage(DF);
    addStorage(OF);
    addStorage(MEM);
    addStorage(BRANCH);
    addStorage(NEXTPC);

    addLabel(new Label("PC", program_counter, 0));
  }

  @Override
  public ProcessingElement copy(final boolean shared) {
    return new PE(this, shared);
  }

  private static final class PEFactory implements Factory {
    @Override
    public PE create() {
      return new PE();
    }
  }

  public static Factory newFactory() {
    return new PEFactory();
  }
}

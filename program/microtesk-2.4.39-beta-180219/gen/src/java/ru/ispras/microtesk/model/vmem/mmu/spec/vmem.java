/*
 * Copyright (c) Institute for System Programming of the Russian Academy of Sciences
 * All Rights Reserved
 *
 * Institute for System Programming of the Russian Academy of Sciences (ISP RAS)
 * 25 Alexander Solzhenitsyn st., Moscow, 109004, Russia
 * http://www.ispras.ru
 *
 * The present file was automatically generated on the basis of formal specifications.
 * It is distributed under the same terms and conditions as the derived specifications.
 *
 * N.B. PLEASE DO NOT MODIFY THIS FILE.
 */

package ru.ispras.microtesk.model.vmem.mmu.spec;

import ru.ispras.fortress.data.Data;
import ru.ispras.fortress.data.DataType;
import ru.ispras.fortress.data.Variable;
import ru.ispras.fortress.data.types.bitvector.BitVector;
import ru.ispras.fortress.expression.Nodes;
import ru.ispras.fortress.expression.NodeValue;
import ru.ispras.fortress.expression.NodeVariable;
import ru.ispras.microtesk.mmu.basis.MemoryOperation;
import ru.ispras.microtesk.mmu.translator.ir.spec.MmuSubsystem;
import java.util.Arrays;
import java.math.BigInteger;
import ru.ispras.microtesk.mmu.basis.BufferAccessEvent;
import ru.ispras.microtesk.mmu.translator.ir.spec.MmuAction;
import ru.ispras.microtesk.mmu.translator.ir.spec.MmuBinding;
import ru.ispras.microtesk.mmu.translator.ir.spec.MmuBufferAccess;
import ru.ispras.microtesk.mmu.translator.ir.spec.MmuGuard;
import ru.ispras.microtesk.mmu.translator.ir.spec.MmuSegment;
import ru.ispras.microtesk.mmu.translator.ir.spec.MmuTransition;

/**
 * The {@code vmem} class is automatically generated by MicroTESK.
 *
 * @author <a href="mailto:microtesk-support@ispras.ru">MicroTESK</a>
 */
public final class vmem {
  public final VA va = VA.get();
  private final PA pa = PA.get();

  public final NodeVariable data;
  private final L1.Entry l1Entry;
  private final MEM.Entry memEntry;

  public final MmuAction START;
  public final MmuAction STOP;

  private final MmuAction IF_READ;
  private final MmuAction ASSIGN_0;
  private final MmuAction BRANCH_0;
  private final MmuAction ASSIGN_1;
  private final MmuAction JOIN_0;
  private final MmuAction BRANCH_1;
  private final MmuAction ASSIGN_2;
  private final MmuAction ASSIGN_3;
  private final MmuAction ASSIGN_4;
  private final MmuAction ASSIGN_5;
  private final MmuAction ASSIGN_6;

  private final MmuAction IF_WRITE;
  private final MmuAction ASSIGN_7;
  private final MmuAction ASSIGN_8;
  private final MmuAction ASSIGN_9;
  private final MmuAction ASSIGN_10;
  private final MmuAction ASSIGN_11;
  private final MmuAction ASSIGN_12;

  protected vmem(final MmuSubsystem.Builder builder) {
    this(builder, "vmem");
  }

  private vmem(final MmuSubsystem.Builder builder, final String name) {
    builder.setName("vmem");

    this.data = new NodeVariable(name + ".data", DataType.bitVector(16));
    builder.setDataVariable(data);

    this.l1Entry = new L1.Entry(name + ".l1Entry");
    builder.registerVariable(l1Entry);

    this.memEntry = new MEM.Entry(name + ".memEntry");
    builder.registerVariable(memEntry);


    this.START = new MmuAction(name + ".START");
    builder.registerAction(START);
    this.STOP = new MmuAction(name + ".STOP");
    builder.registerAction(STOP);

    this.IF_READ = new MmuAction(name + ".IF_READ");
    builder.registerAction(IF_READ);
    builder.registerTransition(new MmuTransition(START, IF_READ, new MmuGuard(MemoryOperation.LOAD)));
    final PA TMP_0 = new PA(name + ".TMP_0");
    TranslateAddress.Function call_0 = TranslateAddress.get().newCall(builder, TMP_0, va);
    builder.registerTransition(new MmuTransition(IF_READ, call_0.START));
    this.ASSIGN_0 = new MmuAction(name + ".ASSIGN_0", pa, TMP_0);
    builder.registerAction(ASSIGN_0);
    builder.registerTransition(new MmuTransition(call_0.STOP, ASSIGN_0));
    this.BRANCH_0 = new MmuAction(name + ".BRANCH_0");
    builder.registerAction(BRANCH_0);
    builder.registerTransition(new MmuTransition(ASSIGN_0, BRANCH_0, new MmuGuard(new MmuBufferAccess(L1.get(), BufferAccessEvent.HIT, L1.get().getAddress(), L1.get(), pa))));
    this.ASSIGN_1 = new MmuAction(name + ".ASSIGN_1", new MmuBufferAccess(L1.get(), BufferAccessEvent.READ, L1.get().getAddress(), L1.get(), pa), l1Entry, L1.get());
    builder.registerAction(ASSIGN_1);
    builder.registerTransition(new MmuTransition(BRANCH_0, ASSIGN_1));
    this.JOIN_0 = new MmuAction(name + ".JOIN_0");
    builder.registerAction(JOIN_0);
    builder.registerTransition(new MmuTransition(ASSIGN_1, JOIN_0));
    this.BRANCH_1 = new MmuAction(name + ".BRANCH_1");
    builder.registerAction(BRANCH_1);
    builder.registerTransition(new MmuTransition(ASSIGN_0, BRANCH_1, new MmuGuard(new MmuBufferAccess(L1.get(), BufferAccessEvent.MISS, L1.get().getAddress(), L1.get(), pa))));
    this.ASSIGN_2 = new MmuAction(name + ".ASSIGN_2", new MmuBufferAccess(MEM.get(), BufferAccessEvent.READ, MEM.get().getAddress(), MEM.get(), pa), memEntry, MEM.get());
    builder.registerAction(ASSIGN_2);
    builder.registerTransition(new MmuTransition(BRANCH_1, ASSIGN_2));
    this.ASSIGN_3 = new MmuAction(name + ".ASSIGN_3", new MmuBinding(l1Entry.tag, Nodes.bvextract(13, 2, pa.value)));
    builder.registerAction(ASSIGN_3);
    builder.registerTransition(new MmuTransition(ASSIGN_2, ASSIGN_3));
    this.ASSIGN_4 = new MmuAction(name + ".ASSIGN_4", new MmuBinding(l1Entry.data, memEntry.data));
    builder.registerAction(ASSIGN_4);
    builder.registerTransition(new MmuTransition(ASSIGN_3, ASSIGN_4));
    this.ASSIGN_5 = new MmuAction(name + ".ASSIGN_5", new MmuBufferAccess(L1.get(), BufferAccessEvent.WRITE, L1.get().getAddress(), L1.get(), null));
    builder.registerAction(ASSIGN_5);
    builder.registerTransition(new MmuTransition(ASSIGN_4, ASSIGN_5));
    builder.registerTransition(new MmuTransition(ASSIGN_5, JOIN_0));
    this.ASSIGN_6 = new MmuAction(name + ".ASSIGN_6", new MmuBinding(data, l1Entry.data));
    builder.registerAction(ASSIGN_6);
    builder.registerTransition(new MmuTransition(JOIN_0, ASSIGN_6));
    builder.registerTransition(new MmuTransition(ASSIGN_6, STOP));

    this.IF_WRITE = new MmuAction(name + ".IF_WRITE");
    builder.registerAction(IF_WRITE);
    builder.registerTransition(new MmuTransition(START, IF_WRITE, new MmuGuard(MemoryOperation.STORE)));
    final PA TMP_1 = new PA(name + ".TMP_1");
    TranslateAddress.Function call_1 = TranslateAddress.get().newCall(builder, TMP_1, va);
    builder.registerTransition(new MmuTransition(IF_WRITE, call_1.START));
    this.ASSIGN_7 = new MmuAction(name + ".ASSIGN_7", pa, TMP_1);
    builder.registerAction(ASSIGN_7);
    builder.registerTransition(new MmuTransition(call_1.STOP, ASSIGN_7));
    this.ASSIGN_8 = new MmuAction(name + ".ASSIGN_8", new MmuBinding(l1Entry.tag, Nodes.bvextract(13, 2, pa.value)));
    builder.registerAction(ASSIGN_8);
    builder.registerTransition(new MmuTransition(ASSIGN_7, ASSIGN_8));
    this.ASSIGN_9 = new MmuAction(name + ".ASSIGN_9", new MmuBinding(l1Entry.data, data));
    builder.registerAction(ASSIGN_9);
    builder.registerTransition(new MmuTransition(ASSIGN_8, ASSIGN_9));
    this.ASSIGN_10 = new MmuAction(name + ".ASSIGN_10", new MmuBufferAccess(L1.get(), BufferAccessEvent.WRITE, L1.get().getAddress(), L1.get(), null));
    builder.registerAction(ASSIGN_10);
    builder.registerTransition(new MmuTransition(ASSIGN_9, ASSIGN_10));
    this.ASSIGN_11 = new MmuAction(name + ".ASSIGN_11", new MmuBinding(memEntry.data, data));
    builder.registerAction(ASSIGN_11);
    builder.registerTransition(new MmuTransition(ASSIGN_10, ASSIGN_11));
    this.ASSIGN_12 = new MmuAction(name + ".ASSIGN_12", new MmuBufferAccess(MEM.get(), BufferAccessEvent.WRITE, MEM.get().getAddress(), MEM.get(), null));
    builder.registerAction(ASSIGN_12);
    builder.registerTransition(new MmuTransition(ASSIGN_11, ASSIGN_12));
    builder.registerTransition(new MmuTransition(ASSIGN_12, STOP));
  }
}

/*
 * Copyright (c) Institute for System Programming of the Russian Academy of Sciences
 * All Rights Reserved
 *
 * Institute for System Programming of the Russian Academy of Sciences (ISP RAS)
 * 25 Alexander Solzhenitsyn st., Moscow, 109004, Russia
 * http://www.ispras.ru
 *
 * The present file was automatically generated on the basis of formal specifications.
 * It is distributed under the same terms and conditions as the derived specifications.
 *
 * N.B. PLEASE DO NOT MODIFY THIS FILE.
 */

package ru.ispras.microtesk.model.vmem.mmu.spec;

import java.util.ArrayList;
import java.util.List;
import ru.ispras.fortress.data.types.bitvector.BitVector;
import ru.ispras.fortress.data.Data;
import ru.ispras.fortress.data.DataType;
import ru.ispras.fortress.data.Variable;
import ru.ispras.fortress.expression.NodeVariable;
import ru.ispras.fortress.expression.Nodes;
import ru.ispras.fortress.expression.NodeValue;
import ru.ispras.microtesk.mmu.translator.ir.spec.MmuSubsystem;
import java.util.Arrays;
import java.math.BigInteger;
import ru.ispras.microtesk.mmu.basis.BufferAccessEvent;
import ru.ispras.microtesk.mmu.translator.ir.spec.MmuAction;
import ru.ispras.microtesk.mmu.translator.ir.spec.MmuBinding;
import ru.ispras.microtesk.mmu.translator.ir.spec.MmuBufferAccess;
import ru.ispras.microtesk.mmu.translator.ir.spec.MmuGuard;
import ru.ispras.microtesk.mmu.translator.ir.spec.MmuSegment;
import ru.ispras.microtesk.mmu.translator.ir.spec.MmuTransition;

/**
 * The {@code TranslateAddress} class is automatically generated by MicroTESK.
 *
 * @author <a href="mailto:microtesk-support@ispras.ru">MicroTESK</a>
 */
public final class TranslateAddress {
  private static TranslateAddress INSTANCE = null;

  public static TranslateAddress get() {
    if (null == INSTANCE) {
      INSTANCE = new TranslateAddress();
    }
    return INSTANCE;
  }

  private int callIndex = 0;

  public final Function newCall(
      final MmuSubsystem.Builder builder,
      final PA TranslateAddress,
      final VA va) {
    return new Function(builder, callIndex++, TranslateAddress, va);
  }

  public static final class Function {
    public final PA TranslateAddress;
    public final VA va;

    private final PA pa;


    public final MmuAction START;
    public final MmuAction STOP;

    private final MmuAction BRANCH_0;
    private final MmuAction AddressError;
    private final MmuAction BRANCH_1;
    private final MmuAction BRANCH_2;
    private final MmuAction JOIN_0;
    private final MmuAction BRANCH_3;
    private final MmuAction BRANCH_4;
    private final MmuAction BRANCH_5;
    private final MmuAction ASSIGN_0;

    private Function(
        final MmuSubsystem.Builder builder,
        final int instanceIndex,
        final PA TranslateAddress,
        final VA va) {
      final String name = String.format("TranslateAddress_%d", instanceIndex);
      this.TranslateAddress = TranslateAddress; 
      this.va = va; 

      this.pa = new PA(name + ".pa");
      builder.registerVariable(pa);

      this.START = new MmuAction(name + ".START");
      builder.registerAction(START);
      this.STOP = new MmuAction(name + ".STOP");
      builder.registerAction(STOP);

      this.BRANCH_0 = new MmuAction(name + ".BRANCH_0");
      builder.registerAction(BRANCH_0);
      builder.registerTransition(new MmuTransition(START, BRANCH_0, new MmuGuard(Nodes.noteq(Nodes.bvextract(0, 0, va.value), NodeValue.newBitVector(0x0, 1)))));
      this.AddressError = new MmuAction(name + ".AddressError", true);
      builder.registerAction(AddressError);
      builder.registerTransition(new MmuTransition(BRANCH_0, AddressError));
      this.BRANCH_1 = new MmuAction(name + ".BRANCH_1");
      builder.registerAction(BRANCH_1);
      builder.registerTransition(new MmuTransition(START, BRANCH_1, new MmuGuard(Nodes.eq(Nodes.bvextract(0, 0, va.value), NodeValue.newBitVector(0x0, 1)))));
      this.BRANCH_2 = new MmuAction(name + ".BRANCH_2");
      builder.registerAction(BRANCH_2);
      builder.registerTransition(new MmuTransition(BRANCH_1, BRANCH_2, new MmuGuard(DIRECT.get(), true)));
      DIRECT.Function call_0 = DIRECT.get().newCall(builder, va, pa);
      builder.registerTransition(new MmuTransition(BRANCH_2, call_0.START));
      this.JOIN_0 = new MmuAction(name + ".JOIN_0");
      builder.registerAction(JOIN_0);
      builder.registerTransition(new MmuTransition(call_0.STOP, JOIN_0));
      this.BRANCH_3 = new MmuAction(name + ".BRANCH_3");
      builder.registerAction(BRANCH_3);
      builder.registerTransition(new MmuTransition(BRANCH_1, BRANCH_3, new MmuGuard(MAPPED.get(), true)));
      MAPPED.Function call_1 = MAPPED.get().newCall(builder, va, pa);
      builder.registerTransition(new MmuTransition(BRANCH_3, call_1.START));
      builder.registerTransition(new MmuTransition(call_1.STOP, JOIN_0));
      this.BRANCH_4 = new MmuAction(name + ".BRANCH_4");
      builder.registerAction(BRANCH_4);
      builder.registerTransition(new MmuTransition(BRANCH_1, BRANCH_4, new MmuGuard(DIRECT.get(), false)));
      this.BRANCH_5 = new MmuAction(name + ".BRANCH_5");
      builder.registerAction(BRANCH_5);
      builder.registerTransition(new MmuTransition(BRANCH_4, BRANCH_5, new MmuGuard(MAPPED.get(), false)));
      builder.registerTransition(new MmuTransition(BRANCH_5, AddressError));
      this.ASSIGN_0 = new MmuAction(name + ".ASSIGN_0", TranslateAddress, pa);
      builder.registerAction(ASSIGN_0);
      builder.registerTransition(new MmuTransition(JOIN_0, ASSIGN_0));
      builder.registerTransition(new MmuTransition(ASSIGN_0, STOP));
    }
  }
}

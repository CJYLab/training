/*
 * Copyright 2015-2017 ISP RAS (http://www.ispras.ru)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES or CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

#define I386_ASSEMBLER

// ==================================================================================
// Constants

let       MEM_SIZE = 2 ** 20 // Memory size

let     GPR_NUMBER = 8 // Number of general-purpose registers
let    SREG_NUMBER = 4 // Number of segmet registers
let REG_INDEX_SIZE = 3 // in bits

// ==================================================================================
// Types

type   BIT = card(1)
type  BYTE = card(8)
type SBYTE = int(8)
type  SIZE = card(4)
type  addR = card(20)
type  WORD = card(16)
type SWORD = int(16)
type DWORD = card(32)
type INDEX = card(REG_INDEX_SIZE)

reg program_counter[addR] // Program counter

// Informs that IP is a program counter. This information
// is needed to handle control transfer ops.
let PC = "program_counter"

// ==================================================================================
// Registers and Memory

// General Purpose Registers
reg GPR[GPR_NUMBER, WORD]

// Accumulator for operands and results data
reg AX[WORD] alias = GPR[0]
reg AL[BYTE] alias = AX<0..7>
reg AH[BYTE] alias = AX<8..15>

// Counter for string and loop operations
reg CX[WORD] alias = GPR[1]
reg CL[BYTE] alias = CX<0..7>
reg CH[BYTE] alias = CX<8..15>

// I/O pointer
reg DX[WORD] alias = GPR[2]
reg DL[BYTE] alias = DX<0..7>
reg DH[BYTE] alias = DX<8..15>

// Pointer to data in the DS segment
reg BX[WORD] alias = GPR[3]
reg BL[BYTE] alias = BX<0..7>
reg BH[BYTE] alias = BX<8..15>

// Pointer to data on the stack
reg SP[WORD] alias = GPR[4]

// Stack pointer
reg BP[WORD] alias = GPR[5]

// Pointer to data in the segment pointed to by the DS register source
// pointer for string operations
reg SI[WORD] alias = GPR[6]

// Pointer to data (or destination) in the segment pointed to by the ES
// register destination pointer for string operations
reg DI[WORD] alias = GPR[7]

// Segment registers
reg RSEG[SREG_NUMBER, WORD]

// Extra segment: General addressing, destination segment in string ops
reg ES[WORD] alias = RSEG[0]
// Code segment: Segment to which IP refers
reg CS[WORD] alias = RSEG[1]
// Stack segment: Segment to which SP refers
reg SS[WORD] alias = RSEG[2]
// Data segment: General addressing, usually for program's data area
reg DS[WORD] alias = RSEG[3]

// Current op address
reg IP[WORD]

// Flags register
reg FLAGS[WORD]

// Flags
reg CF[BIT] alias = FLAGS<0>
reg PF[BIT] alias = FLAGS<2>
reg AF[BIT] alias = FLAGS<4>
reg ZF[BIT] alias = FLAGS<6>
reg SF[BIT] alias = FLAGS<7>
reg TF[BIT] alias = FLAGS<8>
reg IF[BIT] alias = FLAGS<9>
reg DF[BIT] alias = FLAGS<10>
reg OF[BIT] alias = FLAGS<11>

// A memory line
shared mem MEM[MEM_SIZE, BYTE]

// ==================================================================================
// Temporary Variables

// Addressing mode byte
var  rm[card(3)]
var mod[card(2)]

// Instruction size
var instruction_image_size[SIZE]

// Segment override prefix
var base[addR]

// Temporary word-sized variables
var tmpdw_op1[DWORD]
var tmpdw_op2[DWORD]

// Temporary byte-sized variables
var tmpb_op1[BYTE]
var tmpb_op2[BYTE]
var tmpb_res[card(9)]

// Temporary dword-sized variables
var tmpw_op1[WORD]
var tmpw_op2[WORD]
var tmpw_res[card(17)]

// ==================================================================================
// Addressing Modes

// ==================================================================================
// An addressing mode for a register access

mode R16(i: INDEX) = GPR[i]
  syntax = format("%s", if i == 0 then "AX"
                      elif i == 1 then "CX"
                      elif i == 2 then "DX"
                      elif i == 3 then "BX"
                      elif i == 4 then "SP"
                      elif i == 5 then "BP"
                      elif i == 6 then "SI"
                      elif i == 7 then "DI"
                      else "AX"
                      endif)
  image = format("%s", if i == 0 then "000"
                      elif i == 1 then "001"
                      elif i == 2 then "010"
                      elif i == 3 then "011"
                      elif i == 4 then "100"
                      elif i == 5 then "101"
                      elif i == 6 then "110"
                      elif i == 7 then "111"
                      else "000"
                      endif)

mode RSEG16(i: INDEX) = RSEG[i]
  syntax = format("%s", if i == 0 then "ES"
                      elif i == 1 then "CS"
                      elif i == 2 then "SS"
                      elif i == 3 then "DS"
                      else "ES"
                      endif)
  image = format("%s", if i == 0 then "00"
                     elif i == 1 then "01"
                     elif i == 2 then "10"
                     elif i == 3 then "11"
                     else "000"
                     endif)

mode R8(i: INDEX, j: BIT) = if j == 0 then GPR[i]<0..7>
                          else GPR[i]<8..15>
                          endif
  syntax = format("%s", if i == 0 && j == 0 then "AL"
                      elif i == 0 && j == 1 then "AH"
                      elif i == 1 && j == 0 then "CL"
                      elif i == 1 && j == 1 then "CH"
                      elif i == 2 && j == 0 then "DL"
                      elif i == 2 && j == 1 then "DH"
                      elif i == 3 && j == 0 then "BL"
                      elif i == 3 && j == 1 then "BH"
                      else "AL"
                      endif)
  image = format("%s", if i == 0 && j == 0 then "000"
                     elif i == 0 && j == 1 then "100"
                     elif i == 1 && j == 0 then "001"
                     elif i == 1 && j == 1 then "101"
                     elif i == 2 && j == 0 then "010"
                     elif i == 2 && j == 1 then "110"
                     elif i == 3 && j == 0 then "011"
                     elif i == 3 && j == 1 then "111"
                     else "000"
                     endif)

// Immediate operand
mode IMM8(i: BYTE) = i
  syntax = format("%d", i)
  image = format("%s", i)

mode IMM16(i: WORD) = i
  syntax = format("%d", i)
  image = format("%s", i<0..7>::i<8..15>)

// Internal flags
// Branch Processing Variables
mem BRANCH [BIT]
mem NEXTPC [WORD]

// ==================================================================================
// The Displacement Only Addressing Modes

mode DOAM(disp: WORD) = coerce(addR, disp)
  syntax = format("[%d]", disp)
  image = format("%s", disp<0..7>::disp<8..15>)
  init = {
    mod = 0b00;
    rm = 0b110;
  }
  action = {
    instruction_image_size = 2;
  }

// ==================================================================================
// The Register Indirect Addressing Modes

mode RIAM_BX() = coerce(addR, cast(SWORD, BX))
  syntax = format("[BX]")
  image = format("")
  init = {
    mod = 0b00;
    rm = 0b111;
  }
  action = {}

mode RIAM_SI() = coerce(addR, cast(SWORD, SI))
  syntax = format("[SI]")
  image = format("")
  init = {
    mod = 0b00;
    rm = 0b100;
  }
  action = {}

mode RIAM_DI() = coerce(addR, cast(SWORD, DI))
  syntax = format("[DI]")
  image = format("")
  init = {
    mod = 0b00;
    rm = 0b101;
  }
  action = {}

// ==================================================================================
// Based Indexed Addressing Modes

mode BIAM_BX_SI() = coerce(addR, cast(SWORD, BX + SI))
  syntax = format("[BX][SI]")
  image = format("")
  init = {
    mod = 0b00;
    rm = 0b000;
  }
  action = {}

mode BIAM_BX_DI() = coerce(addR, cast(SWORD, BX + DI))
  syntax = format("[BX+DI]")
  image = format("")
  init = {
    mod = 0b00;
    rm = 0b001;
  }
  action = {}

mode BIAM_BP_SI() = coerce(addR, cast(SWORD, BP + SI))
  syntax = format("[BP+SI]")
  image = format("")
  init = {
    mod = 0b00;
    rm = 0b010;
  }
  action = {}

mode BIAM_BP_DI() = coerce(addR, cast(SWORD, BP + DI))
  syntax = format("[BP+DI]")
  image = format("")
  init = {
    mod = 0b00;
    rm = 0b011;
  }
  action = {}

// ==================================================================================
// Indexed Addressing Modes
// with 8-bit signed displacement

mode IAM_BX_D8(disp: SBYTE) = coerce(addR, cast(SWORD, coerce(WORD, disp) + BX))
  syntax = format("%d[BX]", disp)
  image = format("%s", disp)
  init = {
    mod = 0b01;
    rm = 0b111;
  }
  action = {
    instruction_image_size = 1;
  }

mode IAM_BP_D8(disp: SBYTE) = coerce(addR, cast(SWORD, coerce(WORD, disp) + BP))
  syntax = format("%d[BP]", disp)
  image = format("%s", disp)
  init = {
    mod = 0b01;
    rm = 0b110;
  }
  action = {
    instruction_image_size = 1;
  }

mode IAM_SI_D8(disp: SBYTE) = coerce(addR, cast(SWORD, coerce(WORD, disp) + SI))
  syntax = format("%d[SI]", disp)
  image = format("%s", disp)
  init = {
    mod = 0b01;
    rm = 0b100;
  }
  action = {
    instruction_image_size = 1;
  }

mode IAM_DI_D8(disp: SBYTE) = coerce(addR, cast(SWORD, coerce(WORD, disp) + DI))
  syntax = format("%d[DI]", disp)
  image = format("%s", disp)
  init = {
    mod = 0b01;
    rm = 0b101;
  }
  action = {
    instruction_image_size = 1;
  }

// ==================================================================================
// Based Indexed Plus Displacement Addressing Modes
// with 8-bit signed displacement

mode BIDAM_BX_SI_D8(disp: SBYTE) = coerce(addR, cast(SWORD, BX + SI + coerce(WORD, disp)))
  syntax = format("%d[BX+SI]", disp)
  image = format("%s", disp)
  init = {
    mod = 0b01;
    rm = 0b000;
  }
  action = {
    instruction_image_size = 1;
  }

mode BIDAM_BX_DI_D8(disp: SBYTE) = coerce(addR, cast(SWORD, BX + DI + coerce(WORD, disp)))
  syntax = format("%d[BX+DI]", disp)
  image = format("%s", disp)
  init = {
    mod = 0b01;
    rm = 0b001;
  }
  action = {
    instruction_image_size = 1;
  }

mode BIDAM_BP_SI_D8(disp: SBYTE) = coerce(addR, cast(SWORD, BP + SI + coerce(WORD, disp)))
  syntax = format("%d[BP+SI]", disp)
  image = format("%s", disp)
  init = {
    mod = 0b01;
    rm = 0b010;
  }
  action = {
    instruction_image_size = 1;
  }

mode BIDAM_BP_DI_D8(disp: SBYTE) = coerce(addR, cast(SWORD, BP + DI + coerce(WORD, disp)))
  syntax = format("%d[BP+DI]", disp)
  image = format("%s", disp)
  init = {
    mod = 0b01;
    rm = 0b011;
  }
  action = {
    instruction_image_size = 1;
  }

// ==================================================================================
// Indexed Addressing Modes
// with 16-bit unsigned displacement

mode IAM_BX_D16(disp: WORD) = coerce(addR, cast(SWORD, BX + disp))
  syntax = format("%d[BX]", disp)
  image = format("%s", disp<0..7>::disp<8..15>)
  init = {
    mod = 0b11;
    rm = 0b111;
  }
  action = {
    instruction_image_size = 2;
  }

mode IAM_BP_D16(disp: WORD) = coerce(addR, cast(SWORD, BP + disp))
  syntax = format("%d[BP]", disp)
  image = format("%s", disp<0..7>::disp<8..15>)
  init = {
    mod = 0b11;
    rm = 0b110;
  }
  action = {
    instruction_image_size = 2;
  }

mode IAM_SI_D16(disp: WORD) = coerce(addR, cast(SWORD, SI + disp))
  syntax = format("%d[SI]", disp)
  image = format("%s", disp<0..7>::disp<8..15>)
  init = {
    mod = 0b11;
    rm = 0b100;
  }
  action = {
    instruction_image_size = 2;
  }

mode IAM_DI_D16(disp: WORD) = coerce(addR, cast(SWORD, DI + disp))
  syntax = format("%d[DI]", disp)
  image = format("%s", disp<0..7>::disp<8..15>)
  init = {
    mod = 0b11;
    rm = 0b101;
  }
  action = {
    instruction_image_size = 2;
  }

// ==================================================================================
// Based Indexed Plus Displacement Addressing Modes
// with 16-bit unsigned displacement

mode BIDAM_BX_SI_D16(disp: WORD) = coerce(addR, cast(SWORD, BX + SI + disp))
  syntax = format("%d[BX+SI]", disp)
  image = format("%s", disp<0..7>::disp<8..15>)
  init = {
    mod = 0b11;
    rm = 0b000;
  }
  action = {
    instruction_image_size = 2;
  }

mode BIDAM_BX_DI_D16(disp: WORD) = coerce(addR, cast(SWORD, BX + DI + disp))
  syntax = format("%d[BX+DI]", disp)
  image = format("%s", disp<0..7>::disp<8..15>)
  init = {
    mod = 0b11;
    rm = 0b001;
  }
  action = {
    instruction_image_size = 2;
  }

mode BIDAM_BP_SI_D16(disp: WORD) = coerce(addR, cast(SWORD, BP + SI + disp))
  syntax = format("%d[BP+SI]", disp)
  image = format("%s", disp<0..7>::disp<8..15>)
  init = {
    mod = 0b11;
    rm = 0b010;
  }
  action = {
    instruction_image_size = 2;
  }

mode BIDAM_BP_DI_D16(disp: WORD) = coerce(addR, cast(SWORD, BP + DI + disp))
  syntax = format("%d[BP+DI]", disp)
  image = format("%s", disp<0..7>::disp<8..15>)
  init = {
    mod = 0b11;
    rm = 0b011;
  }
  action = {
    instruction_image_size = 2;
  }

mode MOFFS = RIAM_BX | BIAM_BX_SI | IAM_BX_D8 | BIDAM_BX_SI_D8 | IAM_BX_D16 | BIDAM_BX_SI_D16
           | RIAM_SI | BIAM_BX_DI | IAM_BP_D8 | BIDAM_BX_DI_D8 | IAM_BP_D16 | BIDAM_BX_DI_D16
           | RIAM_DI | BIAM_BP_SI | IAM_SI_D8 | BIDAM_BP_SI_D8 | IAM_SI_D16 | BIDAM_BP_SI_D16
           | DOAM    | BIAM_BP_DI | IAM_DI_D8 | BIDAM_BP_DI_D8 | IAM_DI_D16 | BIDAM_BP_DI_D16

// ==================================================================================
// Move ops

op mov_m8r8 (seg_ovrd: RSEG16, dst: MOFFS, src: R8)
  init = { mod = 0b0; rm = 0b0; dst.init;}
  syntax = format("mov %s:%s, %s", seg_ovrd.syntax, dst.syntax, src.syntax)
  image = format("001%s11010001000%s%s%s%s", seg_ovrd.image, mod, src.image, rm, dst.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    MEM[base + dst] = src;
    dst.action;
    instruction_image_size = 3;
  }

op mov_r8m8 (seg_ovrd: RSEG16, dst: R8, src: MOFFS)
  init = { mod = 0b0; rm = 0b0; src.init;}
  syntax = format("mov %s, %s:%s", dst.syntax, seg_ovrd.syntax, src.syntax)
  image = format("001%s11010001010%s%s%s%s", seg_ovrd.image, mod, dst.image, rm, src.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    dst = MEM[base+src];
    src.action;
    instruction_image_size = 3;
  }

op mov_r8r8 (dst: R8, src: R8)
  init = {}
  syntax = format("mov %s, %s", dst.syntax, src.syntax)
  image = format("1000101011%s%s", dst.image, src.image)
  action = {
    dst = src;
    instruction_image_size = 2;
  }

op mov_m16r16 (seg_ovrd: RSEG16, dst: MOFFS, src: R16)
  init = { mod = 0b0; rm = 0b0; dst.init;}
#ifdef I386_ASSEMBLER
  syntax = format("mov word%s, %s", dst.syntax, src.syntax)
#else
  syntax = format("mov %s:%s, %s", seg_ovrd.syntax, dst.syntax, src.syntax)
#endif
  image = format("001%s11010001001%s%s%s%s", seg_ovrd.image, mod, src.image, rm, dst.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    MEM[base+dst]::MEM[base+dst+1] = src<0..7>::src<8..15>;
    dst.action;
    instruction_image_size = 3;
  }

op mov_r16r16 (dst: R16, src: R16)
  init = {}
  syntax = format("mov %s, %s", dst.syntax, src.syntax)
  image = format("1000101111%s%s", dst.image, src.image)
  action = {
    dst = src;
    instruction_image_size = 2;
  }

op mov_r16m16 (seg_ovrd: RSEG16, dst: R16, src: MOFFS)
  init = { mod = 0b0; rm = 0b0; src.init;}
#ifdef I386_ASSEMBLER
  syntax = format("mov %s, word%s", dst.syntax, src.syntax)
#else
  syntax = format("mov %s, %s:%s", dst.syntax, seg_ovrd.syntax, src.syntax)
#endif
  image = format("001%s11010001011%s%s%s%s", seg_ovrd.image, mod, dst.image, rm, src.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    dst<0..7>::dst<8..15> = MEM[base+src]::MEM[base+src+1];
    src.action;
    instruction_image_size = 3;
  }

op mov_r16rseg (dst: R16, src: RSEG16)
  init = {}
  syntax = format("mov %s, %s", dst.syntax, src.syntax)
  image = format("1000110011%s0%s", dst.image, src.image)
  action = {
    dst = src;
    instruction_image_size = 2;
  }

op mov_m16rseg (seg_ovrd: RSEG16, dst: MOFFS, src: RSEG16)
  init = { mod = 0b0; rm = 0b0; dst.init;}
#ifdef I386_ASSEMBLER
  syntax = format("mov word%s, %s", dst.syntax, src.syntax)
#else
  syntax = format("mov %s:%s, %s", seg_ovrd.syntax, dst.syntax, src.syntax)
#endif
  image = format("001%s11010001100%s0%s%s%s", seg_ovrd.image,  mod, src.image, rm, dst.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    MEM[base+dst]::MEM[base+dst+1] = src<0..7>::src<8..15>;
    dst.action;
    instruction_image_size = 3;
  }

op mov_rsegr16 (dst: RSEG16, src: R16)
  init = {}
  syntax = format("mov %s, %s", dst.syntax, src.syntax)
  image = format("10001110110%s%s", dst.image, src.image)
  action = {
    dst = src;
    instruction_image_size = 2;
  }

op mov_rsegm16 (seg_ovrd: RSEG16, dst: RSEG16, src: MOFFS)
  init = { mod = 0b0; rm = 0b0; src.init;}
#ifdef I386_ASSEMBLER
  syntax = format("mov %s, word%s", dst.syntax, src.syntax)
#else
  syntax = format("mov %s, %s:%s", dst.syntax, seg_ovrd.syntax, src.syntax)
#endif
  image = format("001%s11010001110%s0%s%s%s", seg_ovrd.image, mod, dst.image, rm, src.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    dst<0..7>::dst<8..15> = MEM[base+src]::MEM[base+src+1];
    src.action;
    instruction_image_size = 3;
  }

op mov_r8i8 (dst: R8, src: IMM8)
  init = {}
  syntax = format("mov %s, %s", dst.syntax, src.syntax)
  image = format("10110%s11001%s%s", dst.image, dst.image, src.image)
  action = {
    dst = src;
    instruction_image_size = 3;
  }

op mov_r16i16 (dst: R16, src: IMM16)
  init = {}
  syntax = format("mov %s, %s", dst.syntax, src.syntax)
  image = format("10111%s11001%s%s", dst.image, dst.image, src.image)
  action = {
    dst = src;
    instruction_image_size = 4;
  }

op mov_m8i8 (seg_ovrd: RSEG16, dst: MOFFS, src: IMM8)
  init = { mod = 0b0; rm = 0b0; dst.init;}
  syntax = format("mov %s:%s, %s", seg_ovrd.syntax, dst.syntax, src.syntax)
  image = format("001%s11011000110%s001%s%s%s", seg_ovrd.image, mod, rm, dst.image, src.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    MEM[base+dst] = src;
    dst.action;
    instruction_image_size = 4;
  }

op mov_m16i16 (seg_ovrd: RSEG16, dst: MOFFS, src: IMM16)
  init = { mod = 0b0; rm = 0b0; dst.init;}
#ifdef I386_ASSEMBLER
  syntax = format("mov word%s, %s", dst.syntax, src.syntax)
#else
  syntax = format("mov %s:%s, %s", seg_ovrd.syntax, dst.syntax, src.syntax)
#endif
  image = format("001%s11011000111%s001%s%s%s", seg_ovrd.image, mod, rm, dst.image, src.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    MEM[base+dst]::MEM[base+dst+1] = src<0..7>::src<8..15>;
    dst.action;
    instruction_image_size = 5;
  }

op mov = mov_m8r8 | mov_m16r16  | mov_m16rseg
       | mov_r8r8 | mov_r16r16  | mov_rsegm16
       | mov_r8m8 | mov_r16m16  | mov_r16i16
       | mov_r8i8 | mov_r16rseg | mov_m16i16
       | mov_m8i8 | mov_rsegr16

// ==================================================================================
// xchg ops

op xchg_r8r8 (dst: R8, src: R8)
  init = {}
  syntax = format("xchg %s, %s", dst.syntax, src.syntax)
  image = format("1000011011%s%s", dst.image, src.image)
  action = {
    dst = dst ^ src;
    src = src ^ dst;
    dst = dst ^ src;
    instruction_image_size = 2;
  }

op xchg_r8m8 (seg_ovrd: RSEG16, dst: R8, src: MOFFS)
  init = { mod = 0b0; rm = 0b0; src.init;}
  syntax = format("xchg %s, %s:%s", dst.syntax, seg_ovrd.syntax, src.syntax)
  image = format("001%s11010000110%s%s%s%s", seg_ovrd.image, mod, dst.image, rm, src.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    dst = dst ^ MEM[src];
    MEM[base+src] = MEM[base+src] ^ dst;
    dst = dst ^ MEM[base+src];
    src.action;
    instruction_image_size = 3;
  }

op xchg_r16r16 (dst: R16, src: R16)
  init = {}
  syntax = format("xchg %s, %s", dst.syntax, src.syntax)
  image = format("1000011111%s%s", dst.image, src.image)
  action = {
    dst = dst ^ src;
    src = src ^ dst;
    dst = dst ^ src;
    instruction_image_size = 2;
  }

op xchg_r16m16 (seg_ovrd: RSEG16, dst: R16, src: MOFFS)
  init = { mod = 0b0; rm = 0b0; src.init;}
  syntax = format("xchg %s, %s:%s", dst.syntax, seg_ovrd.syntax, src.syntax)
  image = format("001%s11010000111%s%s%s%s", seg_ovrd.image, mod, dst.image, rm, src.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    dst<0..7>::dst<8..15> = dst<0..7>::dst<8..15> ^ MEM[base+src]::MEM[base+src+1];
    MEM[base+src+1]::MEM[base+src] = MEM[base+src+1]::MEM[base+src] ^ dst;
    dst = dst ^ MEM[base+src+1]::MEM[base+src];
    src.action;
    instruction_image_size = 3;
  }

op xchg = xchg_r8r8 | xchg_r16r16
        | xchg_r8m8 | xchg_r16m16


// ==================================================================================
// Stack Operations

// ==================================================================================
// push ops

op push_rseg(src: RSEG16)
  init = {}
  syntax = format("push %s", src.syntax)
  image = format("000%s110", src.image)
  action = {
    base = coerce(addR, SS) << 4;
    SP = SP - 2;
    MEM[base + coerce(addR, cast(SWORD, SP))] = src<0..7>;
    MEM[base + coerce(addR, cast(SWORD, SP + 1))] = src<8..15>;
    instruction_image_size = 1;
  }

op push_r16(src: R16)
  init = {}
  syntax = format("push %s", src.syntax)
  image = format("1010%s", src.image)
  action = {
    base = coerce(addR, SS) << 4;
    SP = SP - 2;
    MEM[base + coerce(addR, cast(SWORD, SP))] = src<0..7>;
    MEM[base + coerce(addR, cast(SWORD, SP + 1))] = src<8..15>;
    instruction_image_size = 1;
  }

op push_m16(seg_ovrd: RSEG16, src: MOFFS)
  init = { mod = 0b0; rm = 0b0; src.init;}
  syntax = format("push %s:%s", seg_ovrd.syntax, src.syntax)
  image = format("001%s11011111111%s000%s%s", seg_ovrd.image, mod, rm, src.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    SP = SP - 2;
    MEM[(coerce(addR, SS) << 4) + coerce(addR, cast(SWORD, SP))] = MEM[base+src];
    MEM[(coerce(addR, SS) << 4) + coerce(addR, cast(SWORD, SP + 1))] = MEM[base+src+1];
    src.action;
    instruction_image_size = 3;
  }

op push = push_rseg | push_r16 | push_m16

// ==================================================================================
// pushA ops

op pushA()
  init = {}
  syntax = format("pushA")
  image = format("01100000")
  action = {
    SP = SP - 16;

    MEM[SS+SP+15] = AH;
    MEM[SS+SP+14] = AL;
    MEM[SS+SP+13] = CH;
    MEM[SS+SP+12] = CL;
    MEM[SS+SP+11] = DH;
    MEM[SS+SP+10] = DL;
    MEM[SS+SP+9]  = BH;
    MEM[SS+SP+8]  = BL;
    MEM[SS+SP+7]  = SP<8..15>;
    MEM[SS+SP+6]  = SP<0..7>;
    MEM[SS+SP+5]  = BP<8..15>;
    MEM[SS+SP+4]  = BP<0..7>;
    MEM[SS+SP+3]  = SI<8..15>;
    MEM[SS+SP+2]  = SI<0..7>;
    MEM[SS+SP+1]  = DI<8..15>;
    MEM[SS+SP+0]  = DI<0..7>;

    instruction_image_size = 1;
  }

// ==================================================================================
// pop ops

op pop_rseg(dst : RSEG16)
  init = {}
  syntax = format("pop %s", dst.syntax)
  image = format("000%s111", dst.image)
  action = {
    base = coerce(addR, SS) << 4;
    dst<0..7> = MEM[base + coerce(addR, cast(SWORD, SP))];
    dst<8..15> = MEM[base + coerce(addR, cast(SWORD, SP + 1))];
    SP = SP + 2;
    instruction_image_size = 1;
  }

op pop_r16(dst : R16)
  init = {}
  syntax = format("pop %s", dst.syntax)
  image = format("01011%s", dst.image)
  action = {
    base = coerce(addR, SS) << 4;
    dst<0..7> = MEM[base + coerce(addR, cast(SWORD, SP))];
    dst<8..15> = MEM[base + coerce(addR, cast(SWORD, SP + 1))];
    SP = SP + 2;
    instruction_image_size = 1;
  }

op pop_m16(seg_ovrd: RSEG16, dst: MOFFS)
  init = { mod = 0b0; rm = 0b0; dst.init;}
  syntax = format("pop %s:%s", seg_ovrd.syntax, dst.syntax)
  image = format("001%s11010001111%s000%s%s", seg_ovrd.image, mod, rm, dst.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    MEM[base+dst] = MEM[(coerce(addR, SS) << 4) + coerce(addR, cast(SWORD, SP))];
    MEM[base+dst+1] = MEM[(coerce(addR, SS) << 4) + coerce(addR, cast(SWORD, SP + 1))];
    SP = SP + 2;
    dst.action;
    instruction_image_size = 3;
  }

op pop = pop_r16 | pop_rseg | pop_m16

// ==================================================================================
// popA ops

op popA()
  init = {}
  syntax = format("popA")
  image = format("01100001")
  action = {
    AH = MEM[SS+SP+15];
    AL = MEM[SS+SP+14];
    CH = MEM[SS+SP+13];
    CL = MEM[SS+SP+12];
    DH = MEM[SS+SP+11];
    DL = MEM[SS+SP+10];
    BH = MEM[SS+SP+9];
    BL = MEM[SS+SP+8];

    BP<8..15> = MEM[SS+SP+5];
    BP<0..7>  = MEM[SS+SP+4];
    SI<8..15> = MEM[SS+SP+3];
    SI<0..7>  = MEM[SS+SP+2];
    DI<8..15> = MEM[SS+SP+1];
    DI<0..7>  = MEM[SS+SP];

    SP = SP + 16;

    instruction_image_size = 1;
  }

// ==================================================================================
// add ops

internal op add_proc_byte(op1: BYTE, op2: BYTE)
  init = {}
  action = {
    tmpb_res = coerce(card(9), op1) + coerce(card(9), op2);

    OF = op1<7> == op2<7> && op1<7> != tmpb_res<7>;

    CF = tmpb_res<8>;

    AF = (~op1<4> & ~op2<4> & tmpb_res<4>) | (~op1<4> & op2<4> & ~tmpb_res<4>) | (op1<4> & ~op2<4> & ~tmpb_res<4>) | (op1<4> & op2<4> & tmpb_res<4>);

    ZF = tmpb_res<0..7> == 0;

    SF = tmpb_res<7> == 1;
  }

internal op add_proc_word(op1: WORD, op2: WORD)
  init = {}
  action = {
    tmpw_res = coerce(card(17), op1) + coerce(card(17), op2);

    AF = (~op1<4> & ~op2<4> & tmpw_res<4>) | (~op1<4> & op2<4> & ~tmpw_res<4>) | (op1<4> & ~op2<4> & ~tmpw_res<4>) | (op1<4> & op2<4> & tmpw_res<4>);

    OF = op1<15> == op2<15> && op1<15> != tmpw_res<15>;

    CF = tmpw_res<16>;

    ZF = tmpw_res<0..15> == 0;

    SF = tmpw_res<15> == 1;
  }

op add_m8r8 (seg_ovrd: RSEG16, op1: MOFFS, op2: R8)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("add %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11000000000%s%s%s%s", seg_ovrd.image, mod, op2.image, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    add_proc_byte(MEM[base+op1], op2 + 0).action;
    MEM[base+op1] = tmpb_res<0..7>;
    op1.action;
    instruction_image_size = 3;
  }

op add_m16r16 (seg_ovrd: RSEG16, op1: MOFFS, op2: R16)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("add %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11000000001%s%s%s%s", seg_ovrd.image, mod, op2.image, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    add_proc_word(MEM[base+op1+1]::MEM[base+op1], op2+0).action;
    MEM[base+op1]::MEM[base+op1+1] = tmpw_res<0..7>::tmpw_res<8..15>;
    op1.action;
    instruction_image_size = 3;
  }

op add_r8r8 (op1: R8, op2: R8)
  init = {}
  syntax = format("add %s, %s", op1.syntax, op2.syntax)
  image = format("0000001011%s%s", op1.image, op2.image)
  action = {
    add_proc_byte(op1+0, op2+0).action;
    op1 = tmpb_res<0..7>;
    instruction_image_size = 2;
  }

op add_r8m8 (seg_ovrd: RSEG16, op1: R8, op2: MOFFS)
  init = { mod = 0b0; rm = 0b0; op2.init;}
  syntax = format("add %s, %s:%s", op1.syntax, seg_ovrd.syntax, op2.syntax)
  image = format("001%s11000000010%s%s%s%s", seg_ovrd.image, mod, op1.image, rm, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    add_proc_byte(op1+0, MEM[base+op2]).action;
    op1 = tmpb_res<0..7>;
    op2.action;
    instruction_image_size = 3;
  }

op add_r16r16 (op1: R16, op2: R16)
  init = {}
  syntax = format("add %s, %s", op1.syntax, op2.syntax)
  image = format("0000001111%s%s", op1.image, op2.image)
  action = {
    add_proc_word(op1+0, op2+0).action;
    op1 = tmpw_res<0..15>;
    instruction_image_size = 2;
  }

op add_r16m16 (seg_ovrd: RSEG16, op1: R16, op2: MOFFS)
  init = { mod = 0b0; rm = 0b0; op2.init;}
  syntax = format("add %s, %s:%s", op1.syntax, seg_ovrd.syntax, op2.syntax)
  image = format("001%s11000000011%s%s%s%s", seg_ovrd.image, mod, op1.image, rm, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    add_proc_word(op1+0, MEM[base+op2+1]::MEM[base+op2]).action;
    op1 = tmpw_res<0..15>;
    op2.action;
    instruction_image_size = 3;
  }

op add_r8i8 (op1: R8, op2: IMM8)
  init = {}
  syntax = format("add %s, %s", op1.syntax, op2.syntax)
  image = format("1000000011000%s%s", op1.image, op2.image)
  action = {
    add_proc_byte(op1+0, op2+0).action;
    op1 = tmpb_res<0..7>;
    instruction_image_size = 3;
  }

op add_m8i8 (seg_ovrd: RSEG16, op1: MOFFS, op2: IMM8)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("add %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11010000000%s000%s%s%s", seg_ovrd.image, mod, rm, op1.image, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    add_proc_byte(MEM[base+op1], op2+0).action;
    MEM[base+op1] = tmpb_res<0..7>;
    op1.action;
    instruction_image_size = 4;
  }

op add_r16i16 (op1: R16, op2: IMM16)
  init = {}
  syntax = format("add %s, %s", op1.syntax, op2.syntax)
  image = format("1000000111000%s%s", op1.image, op2.image)
  action = {
    add_proc_word(op1+0, op2+0).action;
    op1 = tmpw_res<0..15>;
    instruction_image_size = 4;
  }

op add_m16i16 (seg_ovrd: RSEG16, op1: MOFFS, op2: IMM16)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("add %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11010000001%s000%s%s%s", seg_ovrd.image, mod, rm, op1.image, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    add_proc_word(MEM[base+op1+1]::MEM[base+op1], op2+0).action;
    MEM[base+op1]::MEM[base+op1+1] = tmpw_res<0..7>::tmpw_res<8..15>;
    op1.action;
    instruction_image_size = 5;
  }

op add = add_m8r8   | add_r8r8   | add_r8m8   | add_r8i8   | add_m8i8
       | add_r16r16 | add_r16m16 | add_r16i16 | add_m16i16 | add_m16r16

// ==================================================================================
// adc ops

op adc_m8r8 (seg_ovrd: RSEG16, op1: MOFFS, op2: R8)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("adc %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11000010000%s%s%s%s", seg_ovrd.image, mod, op2.image, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    add_proc_byte(MEM[base+op1], op2 + coerce(BYTE, CF)).action;
    MEM[base+op1] = tmpb_res<0..7>;
    op1.action;
    instruction_image_size = 3;
  }

op adc_m16r16 (seg_ovrd: RSEG16, op1: MOFFS, op2: R16)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("adc %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11000010001%s%s%s%s", seg_ovrd.image, mod, op2.image, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    add_proc_word(MEM[base+op1+1]::MEM[base+op1], op2+coerce(WORD, CF)).action;
    MEM[base+op1]::MEM[base+op1+1] = tmpw_res<0..7>::tmpw_res<8..15>;
    op1.action;
    instruction_image_size = 3;
  }

op adc_r8r8 (op1: R8, op2: R8)
  init = {}
  syntax = format("adc %s, %s", op1.syntax, op2.syntax)
  image = format("0001001011%s%s", op1.image, op2.image)
  action = {
    add_proc_byte(op1+0, op2+coerce(BYTE, CF)).action;
    op1 = tmpb_res<0..7>;
    instruction_image_size = 2;
  }

op adc_r8m8 (seg_ovrd: RSEG16, op1: R8, op2: MOFFS)
  init = { mod = 0b0; rm = 0b0; op2.init;}
  syntax = format("adc %s, %s:%s", op1.syntax, seg_ovrd.syntax, op2.syntax)
  image = format("001%s11000010010%s%s%s%s", seg_ovrd.image, mod, op1.image, rm, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    add_proc_byte(op1+coerce(BYTE, CF), MEM[base+op2]).action;
    op1 = tmpb_res<0..7>;
    op2.action;
    instruction_image_size = 3;
  }

op adc_r16r16 (op1: R16, op2: R16)
  init = {}
  syntax = format("adc %s, %s", op1.syntax, op2.syntax)
  image = format("0001001111%s%s", op1.image, op2.image)
  action = {
    add_proc_word(op1+0, op2+coerce(WORD, CF)).action;
    op1 = tmpw_res<0..15>;
    instruction_image_size = 2;
  }

op adc_r16m16 (seg_ovrd: RSEG16, op1: R16, op2: MOFFS)
  init = { mod = 0b0; rm = 0b0; op2.init;}
  syntax = format("adc %s, %s:%s", op1.syntax, seg_ovrd.syntax, op2.syntax)
  image = format("001%s11000010011%s%s%s%s", seg_ovrd.image, mod, op1.image, rm, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    add_proc_word(op1+coerce(WORD, CF), MEM[base+op2+1]::MEM[base+op2]).action;
    op1 = tmpw_res<0..15>;
    op2.action;
    instruction_image_size = 3;
  }

op adc_r8i8 (op1: R8, op2: IMM8)
  init = {}
  syntax = format("adc %s, %s", op1.syntax, op2.syntax)
  image = format("1000000011000%s%s", op1.image, op2.image)
  action = {
    add_proc_byte(op1+0, op2+coerce(BYTE, CF)).action;
    op1 = tmpb_res<0..7>;
    instruction_image_size = 3;
  }

op adc_m8i8 (seg_ovrd: RSEG16, op1: MOFFS, op2: IMM8)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("adc %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11010000000%s000%s%s%s", seg_ovrd.image, mod, rm, op1.image, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    add_proc_byte(MEM[base+op1], op2+coerce(BYTE, CF)).action;
    MEM[base+op1] = tmpb_res<0..7>;
    op1.action;
    instruction_image_size = 4;
  }

op adc_r16i16 (op1: R16, op2: IMM16)
  init = {}
  syntax = format("adc %s, %s", op1.syntax, op2.syntax)
  image = format("1000000111000%s%s", op1.image, op2.image)
  action = {
    add_proc_word(op1+0, op2+coerce(WORD, CF)).action;
    op1 = tmpw_res<0..15>;
    instruction_image_size = 4;
  }

op adc_m16i16 (seg_ovrd: RSEG16, op1: MOFFS, op2: IMM16)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("adc %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11010000001%s000%s%s%s", seg_ovrd.image, mod, rm, op1.image, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    add_proc_word(MEM[base+op1+1]::MEM[base+op1], op2+coerce(WORD, CF)).action;
    MEM[base+op1]::MEM[base+op1+1] = tmpw_res<0..7>::tmpw_res<8..15>;
    op1.action;
    instruction_image_size = 5;
  }

op adc = adc_m8r8   | adc_r8r8   | adc_r8m8   | adc_r8i8   | adc_m8i8
       | adc_r16r16 | adc_r16m16 | adc_r16i16 | adc_m16i16 | adc_m16r16

// ==================================================================================
// sub ops

var temp_bit [BIT] // TODO: temp_bit = op2<15> != 1;
internal op sub_proc_byte(op1: BYTE, op2: BYTE)
  action = {
    tmpb_res = coerce(card(9), op1) - coerce(card(9), op2);

    temp_bit = op2<7> != 1;
    OF = op1<7> == temp_bit && op1<7> != tmpb_res<7>;

    CF = tmpb_res<8>;

    AF = (~op1<4> & ~op2<4> & tmpb_res<4>)
       | (~op1<4> & op2<4> & ~tmpb_res<4>)
       | (op1<4> & ~op2<4> & ~tmpb_res<4>)
       | (op1<4> & op2<4> & tmpb_res<4>);

    ZF = tmpb_res<0..7> == 0;

    SF = tmpb_res<7> == 1;
  }

internal op sub_proc_word(op1: WORD, op2: WORD)
  action = {
    tmpw_res = coerce(card(17), op1) - coerce(card(17), op2);
    AF = (~op1<4> & ~op2<4> & tmpw_res<4>)
       | (~op1<4> & op2<4> & ~tmpw_res<4>)
       | (op1<4> & ~op2<4> & ~tmpw_res<4>)
       | (op1<4> & op2<4> & tmpw_res<4>);

    temp_bit = op2<15> != 1;
    OF = op1<15> == temp_bit && op1<15> != tmpw_res<15>;

    CF = tmpw_res<16>;

    ZF = tmpw_res<0..16> == 0;

    SF = tmpw_res<15> == 1;
  }

op sub_m8r8 (seg_ovrd: RSEG16, op1: MOFFS, op2: R8)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("sub %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11000101000%s%s%s%s", seg_ovrd.image, mod, op2.image, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    sub_proc_byte(MEM[base+op1], op2 + 0).action;
    MEM[base+op1] = tmpb_res<0..7>;
    op1.action;
    instruction_image_size = 3;
  }

op sub_m16r16 (seg_ovrd: RSEG16, op1: MOFFS, op2: R16)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("sub %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11000101001%s%s%s%s", seg_ovrd.image, mod, op2.image, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    sub_proc_word(MEM[base+op1+1]::MEM[base+op1], op2+0).action;
    MEM[base+op1]::MEM[base+op1+1] = tmpw_res<0..7>::tmpw_res<8..15>;
    op1.action;
    instruction_image_size = 3;
  }

op sub_r8r8 (op1: R8, op2: R8)
  init = {}
  syntax = format("sub %s, %s", op1.syntax, op2.syntax)
  image = format("0010101011%s%s", op1.image, op2.image)
  action = {
    sub_proc_byte(op1+0, op2+0).action;
    op1 = tmpb_res<0..7>;
    instruction_image_size = 2;
  }

op sub_r8m8 (seg_ovrd: RSEG16, op1: R8, op2: MOFFS)
  init = { mod = 0b0; rm = 0b0; op2.init;}
  syntax = format("sub %s, %s:%s", op1.syntax, seg_ovrd.syntax, op2.syntax)
  image = format("001%s11000101010%s%s%s%s", seg_ovrd.image, mod, op1.image, rm, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    sub_proc_byte(op1+0, MEM[base+op2]).action;
    op1 = tmpb_res<0..7>;
    op2.action;
    instruction_image_size = 3;
  }

op sub_r16r16 (op1: R16, op2: R16)
  init = {}
  syntax = format("sub %s, %s", op1.syntax, op2.syntax)
  image = format("0010101111%s%s", op1.image, op2.image)
  action = {
    sub_proc_word(op1+0, op2+0).action;
    op1 = tmpw_res<0..15>;
    instruction_image_size = 2;
  }

op sub_r16m16 (seg_ovrd: RSEG16, op1: R16, op2: MOFFS)
  init = { mod = 0b0; rm = 0b0; op2.init;}
  syntax = format("sub %s, %s:%s", op1.syntax, seg_ovrd.syntax, op2.syntax)
  image = format("001%s11000101011%s%s%s%s", seg_ovrd.image, mod, op1.image, rm, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    sub_proc_word(op1+0, MEM[base+op2+1]::MEM[base+op2]).action;
    op1 = tmpw_res<0..15>;
    op2.action;
    instruction_image_size = 3;
  }

op sub_r8i8 (op1: R8, op2: IMM8)
  init = {}
  syntax = format("sub %s, %s", op1.syntax, op2.syntax)
  image = format("1000000011000%s%s", op1.image, op2.image)
  action = {
    sub_proc_byte(op1+0, op2+0).action;
    op1 = tmpb_res<0..7>;
    instruction_image_size = 3;
  }

op sub_m8i8 (seg_ovrd: RSEG16, op1: MOFFS, op2: IMM8)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("sub %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11010000000%s000%s%s%s", seg_ovrd.image, mod, rm, op1.image, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    sub_proc_byte(MEM[base+op1], op2+0).action;
    MEM[base+op1] = tmpb_res<0..7>;
    op1.action;
    instruction_image_size = 4;
  }

op sub_r16i16 (op1: R16, op2: IMM16)
  init = {}
  syntax = format("sub %s, %s", op1.syntax, op2.syntax)
  image = format("1000000111000%s%s", op1.image, op2.image)
  action = {
    sub_proc_word(op1+0, op2+0).action;
    op1 = tmpw_res<0..15>;
    instruction_image_size = 4;
  }

op sub_m16i16 (seg_ovrd: RSEG16, op1: MOFFS, op2: IMM16)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("sub %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11010000001%s000%s%s%s", seg_ovrd.image, mod, rm, op1.image, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    sub_proc_word(MEM[base+op1+1]::MEM[base+op1], op2+0).action;
    MEM[base+op1]::MEM[base+op1+1] = tmpw_res<0..7>::tmpw_res<8..15>;
    op1.action;
    instruction_image_size = 5;
  }

op sub = sub_m8r8   | sub_r8r8   | sub_r8m8   | sub_r8i8   | sub_m8i8
       | sub_r16r16 | sub_r16m16 | sub_r16i16 | sub_m16i16 | sub_m16r16

// ==================================================================================
// sbb ops

op sbb_m8r8 (seg_ovrd: RSEG16, op1: MOFFS, op2: R8)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("sbb %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11000011000%s%s%s%s", seg_ovrd.image, mod, op2.image, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    sub_proc_byte(MEM[base+op1], op2-coerce(BYTE, CF)).action;
    MEM[base+op1] = tmpb_res<0..7>;
    op1.action;
    instruction_image_size = 3;
  }

op sbb_m16r16 (seg_ovrd: RSEG16, op1: MOFFS, op2: R16)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("sbb %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11000011001%s%s%s%s", seg_ovrd.image, mod, op2.image, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    sub_proc_word(MEM[base+op1+1]::MEM[base+op1], op2-coerce(WORD, CF)).action;
    MEM[base+op1]::MEM[base+op1+1] = tmpw_res<0..7>::tmpw_res<8..15>;
    op1.action;
    instruction_image_size = 3;
  }

op sbb_r8r8 (op1: R8, op2: R8)
  init = {}
  syntax = format("sbb %s, %s", op1.syntax, op2.syntax)
  image = format("0001101011%s%s", op1.image, op2.image)
  action = {
    sub_proc_byte(op1+0, op2-coerce(BYTE, CF)).action;
    op1 = tmpb_res<0..7>;
    instruction_image_size = 2;
  }

op sbb_r8m8 (seg_ovrd: RSEG16, op1: R8, op2: MOFFS)
  init = { mod = 0b0; rm = 0b0; op2.init;}
  syntax = format("sbb %s, %s:%s", op1.syntax, seg_ovrd.syntax, op2.syntax)
  image = format("001%s11000011010%s%s%s%s", seg_ovrd.image, mod, op1.image, rm, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    sub_proc_byte(op1-coerce(BYTE, CF), MEM[base+op2]).action;
    op1 = tmpb_res<0..7>;
    op2.action;
    instruction_image_size = 3;
  }

op sbb_r16r16 (op1: R16, op2: R16)
  init = {}
  syntax = format("sbb %s, %s", op1.syntax, op2.syntax)
  image = format("0001101111%s%s", op1.image, op2.image)
  action = {
    sub_proc_word(op1+0, op2-coerce(WORD, CF)).action;
    op1 = tmpw_res<0..15>;
    instruction_image_size = 2;
  }

op sbb_r16m16 (seg_ovrd: RSEG16, op1: R16, op2: MOFFS)
  init = { mod = 0b0; rm = 0b0; op2.init;}
  syntax = format("sbb %s, %s:%s", op1.syntax, seg_ovrd.syntax, op2.syntax)
  image = format("001%s11000011011%s%s%s%s", seg_ovrd.image, mod, op1.image, rm, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    sub_proc_word(op1-coerce(WORD, CF), MEM[base+op2+1]::MEM[base+op2]).action;
    op1 = tmpw_res<0..15>;
    op2.action;
    instruction_image_size = 3;
  }

op sbb_r8i8 (op1: R8, op2: IMM8)
  init = {}
  syntax = format("sbb %s, %s", op1.syntax, op2.syntax)
  image = format("1000000011000%s%s", op1.image, op2.image)
  action = {
    sub_proc_byte(op1+0, op2-coerce(BYTE, CF)).action;
    op1 = tmpb_res<0..7>;
    instruction_image_size = 3;
  }

op sbb_m8i8 (seg_ovrd: RSEG16, op1: MOFFS, op2: IMM8)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("sbb %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11010000000%s000%s%s%s", seg_ovrd.image, mod, rm, op1.image, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    sub_proc_byte(MEM[base+op1], op2-coerce(BYTE, CF)).action;
    MEM[base+op1] = tmpb_res<0..7>;
    op1.action;
    instruction_image_size = 4;
  }

op sbb_r16i16 (op1: R16, op2: IMM16)
  init = {}
  syntax = format("sbb %s, %s", op1.syntax, op2.syntax)
  image = format("1000000111000%s%s", op1.image, op2.image)
  action = {
    sub_proc_word(op1+0, op2-coerce(WORD, CF)).action;
    op1 = tmpw_res<0..15>;
    instruction_image_size = 4;
  }

op sbb_m16i16 (seg_ovrd: RSEG16, op1: MOFFS, op2: IMM16)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("sbb %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11010000001%s000%s%s%s", seg_ovrd.image, mod, rm, op1.image, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    sub_proc_word(MEM[base+op1+1]::MEM[base+op1], op2-coerce(WORD, CF)).action;
    MEM[base+op1]::MEM[base+op1+1] = tmpw_res<0..7>::tmpw_res<8..15>;
    op1.action;
    instruction_image_size = 5;
  }

op sbb = sbb_m8r8   | sbb_r8r8   | sbb_r8m8   | sbb_r8i8   | sbb_m8i8
       | sbb_r16r16 | sbb_r16m16 | sbb_r16i16 | sbb_m16i16 | sbb_m16r16

// ==================================================================================
// inc ops

internal op inc_proc_byte(op1: BYTE)
  action = {
    tmpb_res = coerce(card(9), op1 + 1);

    OF = op1<7> == 0 && tmpb_res<7> == 1;

    ZF = tmpb_res<0..7> == 0;

    SF = tmpb_res<7> == 1;
  }

internal op inc_proc_word(op1: WORD)
  action = {
    tmpw_res = coerce(card(17), op1 + 1);

    OF = op1<15> == 0 && tmpw_res<15> == 1;

    ZF = tmpw_res<0..15> == 0;

    SF = tmpw_res<15> == 1;
  }

op inc_r8 (op1: R8)
  init = {}
  syntax = format("inc %s", op1.syntax)
  image = format("1111111011001%s", op1.image)
  action = {
    inc_proc_byte(op1+0).action;
    op1 = tmpb_res<0..7>;
    instruction_image_size = 2;
  }

op inc_m8 (seg_ovrd: RSEG16, op1: MOFFS)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("inc %s:%s", seg_ovrd.syntax, op1.syntax)
  image = format("001%s11011111110%s001%s%s", seg_ovrd.image, mod, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    inc_proc_byte(MEM[base+op1]).action;
    MEM[base+op1] = tmpb_res<0..7>;
    op1.action;
    instruction_image_size = 3;
  }

op inc_r16 (op1: R16)
  init = {}
  syntax = format("inc %s", op1.syntax)
  image = format("1000%s11001%s", op1.image, op1.image)
  action = {
    inc_proc_word(op1+0).action;
    op1 = tmpw_res<0..15>;
    instruction_image_size = 2;
  }

op inc_m16 (seg_ovrd: RSEG16, op1: MOFFS)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("inc %s:%s", seg_ovrd.syntax, op1.syntax)
  image = format("001%s11011111111%s001%s%s", seg_ovrd.image, mod, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    inc_proc_word(MEM[base+op1+1]::MEM[base+op1]).action;
    MEM[base+op1] = tmpw_res<0..7>;
    MEM[base+op1+1] = tmpw_res<8..15>;
    op1.action;
    instruction_image_size = 3;
  }

op inc = inc_r8 | inc_m8 | inc_r16 | inc_m16

// ==================================================================================
// dec ops

internal op dec_proc_byte(op1: BYTE)
  action = {
    tmpb_res = coerce(card(9), op1 - 1);

    OF = op1<7> == 0 && tmpb_res<7> == 1;

    ZF = tmpb_res<0..7> == 0;

    SF = tmpb_res<7> == 1;
  }

internal op dec_proc_word(op1: WORD)
  action = {
    tmpw_res = coerce(card(17), op1 - 1);

    OF = op1<15> == 0 && tmpw_res<15> == 1;

    ZF = tmpw_res<0..15> == 0;

    SF = tmpw_res<15> == 1;
  }

op dec_r8 (op1: R8)
  init = {}
  syntax = format("dec %s", op1.syntax)
  image = format("1111111011001%s", op1.image)
  action = {
    dec_proc_byte(op1+0).action;
    op1 = tmpb_res<0..7>;
    instruction_image_size = 2;
  }

op dec_m8 (seg_ovrd: RSEG16, op1: MOFFS)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("dec %s:%s", seg_ovrd.syntax, op1.syntax)
  image = format("001%s11011111110%s001%s%s", seg_ovrd.image, mod, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    dec_proc_byte(MEM[base+op1]).action;
    MEM[base+op1] = tmpb_res<0..7>;
    op1.action;
    instruction_image_size = 3;
  }

op dec_r16 (op1: R16)
  init = {}
  syntax = format("dec %s", op1.syntax)
  image = format("1001%s11001%s", op1.image, op1.image)
  action = {
    dec_proc_word(op1+0).action;
    op1 = tmpw_res<0..15>;
    instruction_image_size = 2;
  }

op dec_m16 (seg_ovrd: RSEG16, op1: MOFFS)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("dec %s:%s", seg_ovrd.syntax, op1.syntax)
  image = format("001%s11011111111%s001%s%s", seg_ovrd.image, mod, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    dec_proc_word(MEM[base+op1+1]::MEM[base+op1]).action;
    MEM[base+op1] = tmpw_res<0..7>;
    MEM[base+op1+1] = tmpw_res<8..15>;
    op1.action;
    instruction_image_size = 3;
  }

op dec = dec_r8 | dec_m8 | dec_r16 | dec_m16

// ==================================================================================
// mul ops

op mul_r8(op1: R8)
  init = {}
  syntax = format("mul %s", op1.syntax)
  image = format("1111011011000%s", op1.image)
  action = {
    AX = coerce(WORD, AL) * coerce(WORD, op1);
    instruction_image_size = 2;
    if AH != 0 then
      OF = 1;
      CF = 1;
    else
      OF = 0;
      CF = 0;
    endif;
  }

op mul_m8(seg_ovrd: RSEG16, op1: MOFFS)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("mul %s:%s", seg_ovrd.syntax, op1.syntax)
  image = format("001%s11011110110%s000%s%s", seg_ovrd.image, mod, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    AX = coerce(WORD, AL) * coerce(WORD, MEM[base+op1]);
    instruction_image_size = 3;
    op1.action;
    if AH != 0 then
      OF = 1;
      CF = 1;
    else
      OF = 0;
      CF = 0;
    endif;
  }

op mul_r16(op1: R16)
  init = {}
  syntax = format("mul %s", op1.syntax)
  image = format("1111011111000%s", op1.image)
  action = {
    tmpdw_op1 = coerce(DWORD, AX) * coerce(DWORD, op1);
    instruction_image_size = 2;
    AX = tmpdw_op1<0..15>;
    DX = tmpdw_op1<16..31>;
    if DX != 0 then
      OF = 1;
      CF = 1;
    else
      OF = 0;
      CF = 0;
    endif;
  }

op mul_m16(seg_ovrd: RSEG16, op1: MOFFS)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("mul %s:%s", seg_ovrd.syntax, op1.syntax)
  image = format("001%s11011110111%s000%s%s", seg_ovrd.image, mod, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    tmpdw_op1 = coerce(DWORD, AX) * coerce(DWORD, (MEM[base+op1+1]::MEM[base+op1]));
    instruction_image_size = 3;
    op1.action;
    AX = tmpdw_op1<0..15>;
    DX = tmpdw_op1<16..31>;
    if DX != 0 then
      OF = 1;
      CF = 1;
    else
      OF = 0;
      CF = 0;
    endif;
  }

op mul = mul_r8 | mul_m8 | mul_r16 | mul_m16

// ==================================================================================
// imul ops

op imul_r8(op1: R8)
  init = {}
  syntax = format("imul %s", op1.syntax)
  image = format("1111011011000%s", op1.image)
  action = {
    AX = coerce(WORD, cast(SBYTE, AL)) * coerce(WORD, cast(SBYTE, op1));
    instruction_image_size = 2;
    if AH == 0 || AH == 0xff then
      OF = 0;
      CF = 0;
    else
      OF = 1;
      CF = 1;
    endif;
  }

op imul_m8(seg_ovrd: RSEG16, op1: MOFFS)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("imul %s:%s", seg_ovrd.syntax, op1.syntax)
  image = format("001%s11011110110%s000%s%s", seg_ovrd.image, mod, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    AX = coerce(WORD, cast(SBYTE, AL)) * coerce(WORD, cast(SBYTE, MEM[base+op1]));
    instruction_image_size = 3;
    op1.action;
    if AH == 0 || AH == 0xff then
      OF = 0;
      CF = 0;
    else
      OF = 1;
      CF = 1;
    endif;
  }

op imul_r16(op1: R16)
  init = {}
  syntax = format("imul %s", op1.syntax)
  image = format("1111011111000%s", op1.image)
  action = {
    tmpdw_op1 = coerce(DWORD, cast(SWORD, AX)) * coerce(DWORD, cast(SWORD, op1));
    instruction_image_size = 2;
    AX = tmpdw_op1<0..15>;
    DX = tmpdw_op1<16..31>;
    if DX == 0 || DX == 0xff then
      OF = 0;
      CF = 0;
    else
      OF = 1;
      CF = 1;
    endif;
  }

op imul_m16(seg_ovrd: RSEG16, op1: MOFFS)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("imul %s:%s", seg_ovrd.syntax, op1.syntax)
  image = format("001%s11011110111%s000%s%s", seg_ovrd.image, mod, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    tmpdw_op1 = coerce(DWORD, cast(SWORD, AX)) *
                coerce(DWORD, cast(SWORD, MEM[base+op1+1]::MEM[base+op1]));
    instruction_image_size = 3;
    op1.action;
    AX = tmpdw_op1<0..15>;
    DX = tmpdw_op1<16..31>;
    if DX == 0 || DX == 0xff then
      OF = 0;
      CF = 0;
    else
      OF = 1;
      CF = 1;
    endif;
  }

op imul = imul_r8 | imul_m8 | imul_r16 | imul_m16

// ==================================================================================
// div ops

op div_r8(op1: R8)
  init = {}
  syntax = format("div %s", op1.syntax)
  image = format("1111011011000%s", op1.image)
  action = {
    tmpw_op1 = AX / coerce(WORD, op1);
    instruction_image_size = 2;
    if tmpw_op1 <= 0xff then
      AH = coerce(BYTE, AX % coerce(WORD, op1));
      AL = coerce(BYTE, tmpw_op1);
    endif;
  }

op div_m8(seg_ovrd: RSEG16, op1: MOFFS)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("div %s:%s", seg_ovrd.syntax, op1.syntax)
  image = format("001%s11011110110%s000%s%s", seg_ovrd.image, mod, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    tmpw_op1 = AX / coerce(WORD, MEM[base+op1]);
    instruction_image_size = 3;
    op1.action;
    if tmpw_op1 <= 0xff then
      AH = coerce(BYTE, AX % coerce(WORD, MEM[base+op1]));
      AL = coerce(BYTE, tmpw_op1);
    endif;
  }

op div_r16(op1: R16)
  init = {}
  syntax = format("div %s", op1.syntax)
  image = format("1111011111000%s", op1.image)
  action = {
    tmpdw_op1<0..15> = AX;
    tmpdw_op1<16..31> = DX;
    tmpdw_op2 = tmpdw_op1 / coerce(DWORD, op1);
    instruction_image_size = 2;
    if tmpdw_op1 <= 0xffff then
      AX = coerce(WORD, tmpdw_op2);
      DX = coerce(WORD, tmpdw_op1 % coerce(DWORD, op1));
    endif;
  }

op div_m16(seg_ovrd: RSEG16, op1: MOFFS)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("div %s:%s", seg_ovrd.syntax, op1.syntax)
  image = format("001%s11011110111%s000%s%s", seg_ovrd.image, mod, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    tmpdw_op1<0..15> = AX;
    tmpdw_op1<16..31> = DX;
    tmpw_op1<0..7> = MEM[base+op1];
    tmpw_op1<8..15> = MEM[base+op1+1];
    tmpdw_op2 = tmpdw_op1 / coerce(DWORD, tmpw_op1);
    instruction_image_size = 3;
    op1.action;
    if tmpdw_op1 <= 0xffff then
      AX = coerce(WORD, tmpdw_op2);
      DX = coerce(WORD, tmpdw_op1 % coerce(DWORD, tmpw_op1));
    endif;
  }

op div = div_r8 | div_m8 | div_r16 | div_m16

// ==================================================================================
// idiv ops

op idiv_r8(op1: R8)
  init = {}
  syntax = format("idiv %s", op1.syntax)
  image = format("1111011011000%s", op1.image)
  action = {
    tmpw_op1 = cast(SWORD, AX) / coerce(SWORD, cast(SBYTE, op1));
    instruction_image_size = 2;
    if tmpw_op1 <= 0x7f && tmpw_op1 >= 0x80 then
      AH = coerce(BYTE, AX % coerce(WORD, cast(SBYTE, op1)));
      AL = coerce(BYTE, tmpw_op1);
    endif;
  }

op idiv_m8(seg_ovrd: RSEG16, op1: MOFFS)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("idiv %s:%s", seg_ovrd.syntax, op1.syntax)
  image = format("001%s11011110110%s000%s%s", seg_ovrd.image, mod, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    tmpw_op1 = cast(SWORD, AX) / coerce(SWORD, cast(SBYTE, MEM[base+op1]));
    instruction_image_size = 3;
    op1.action;
    if tmpw_op1 <= 0x7f && tmpw_op1 >= 0x80 then
      AH = coerce(BYTE, AX % coerce(WORD, cast(SBYTE, MEM[base+op1])));
      AL = coerce(BYTE, tmpw_op1);
    endif;
  }

op idiv_r16(op1: R16)
  init = {}
  syntax = format("idiv %s", op1.syntax)
  image = format("1111011111000%s", op1.image)
  action = {
    tmpdw_op1<0..15> = AX;
    tmpdw_op1<16..31> = DX;
    tmpdw_op2 = tmpdw_op1 / coerce(DWORD, cast(SWORD, op1));
    trace("delimoe %d delitel %d div %d", tmpdw_op1, cast(SWORD, op1),  tmpdw_op2);
    instruction_image_size = 2;
    if !((tmpdw_op2 > 0x7fff) || (tmpdw_op2 < 0x8000)) then
      AX = coerce(WORD, tmpdw_op2);
      DX = coerce(WORD, tmpdw_op1 % coerce(DWORD, cast(SWORD, op1)));
    endif;
  }

op idiv_m16(seg_ovrd: RSEG16, op1: MOFFS)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("idiv %s:%s", seg_ovrd.syntax, op1.syntax)
  image = format("001%s11011110111%s000%s%s", seg_ovrd.image, mod, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    tmpdw_op1<0..15> = AX;
    tmpdw_op1<16..31> = DX;
    tmpw_op1<0..7> = MEM[base+op1];
    tmpw_op1<8..15> = MEM[base+op1+1];
    tmpdw_op2 = tmpdw_op1 / coerce(DWORD, cast(SWORD, tmpw_op1));
    instruction_image_size = 3;
    op1.action;
    if !((tmpdw_op2 > 0x7fff) || (tmpdw_op2 < 0x8000)) then
      AX = coerce(WORD, tmpdw_op2);
      DX = coerce(WORD, tmpdw_op1 % coerce(DWORD, cast(SWORD, tmpw_op1)));
    endif;
  }

op idiv = idiv_r8 | idiv_m8 | idiv_r16 | idiv_m16

// ==================================================================================
// test ops

internal op test_proc_byte(op1: BYTE, op2: BYTE)
  action = {
    tmpb_res = coerce(card(9), op1 & op2);
    CF = 0;
    OF = 0;
    SF = tmpb_res<7>;
    ZF = tmpb_res<0..7> == 0;
  }

internal op test_proc_word(op1: WORD, op2: WORD)
  action = {
    tmpw_res = coerce(card(17), op1 & op2);
    CF = 0;
    OF = 0;
    SF = tmpw_res<15>;
    ZF = tmpw_res<0..15> == 0;
  }

op test_r8r8(op1: R8, op2: R8)
  init = {}
  syntax = format("test %s, %s", op1.syntax, op2.syntax)
  image = format("1000010011%s%s", op1.image, op2.image)
  action = {
    test_proc_byte(op1+0, op2+0).action;
    instruction_image_size = 2;
  }

op test_m8r8(seg_ovrd: RSEG16, op1: MOFFS, op2: R8)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("test %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11010000100%s%s%s%s", seg_ovrd.image, mod, op2.image, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    test_proc_byte(MEM[base+op1], op2+0).action;
    op1.action;
    instruction_image_size = 3;
  }

op test_r16r16(op1: R16, op2: R16)
  init = {}
  syntax = format("test %s, %s", op1.syntax, op2.syntax)
  image = format("1000010111%s%s", op1.image, op2.image)
  action = {
    test_proc_word(op1+0, op2+0).action;
    instruction_image_size = 2;
  }

op test_m16r16(seg_ovrd: RSEG16, op1: MOFFS, op2: R16)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("test %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11010000101%s%s%s%s", seg_ovrd.image, mod, op2.image, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    test_proc_word(MEM[base+op1+1]::MEM[base+op1], op2+0).action;
    op1.action;
    instruction_image_size = 3;
  }

op test_r8i8(op1: R8, op2: IMM8)
  init = {}
  syntax = format("test %s, %s", op1.syntax, op2.syntax)
  image = format("1111011011000%s%s", op1.image, op2.image)
  action = {
    test_proc_byte(op1+0, op2+0).action;
    instruction_image_size = 3;
  }

op test_m8i8(seg_ovrd: RSEG16, op1: MOFFS, op2: IMM8)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("test %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11011110110%s000%s%s%s", seg_ovrd.image, mod, rm, op1.image, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    test_proc_byte(MEM[base+op1], op2+0).action;
    op1.action;
    instruction_image_size = 4;
  }

op test_r16i16(op1: R16, op2: IMM16)
  init = {}
  syntax = format("test %s, %s", op1.syntax, op2.syntax)
  image = format("1111011111000%s%s", op1.image, op2.image)
  action = {
    test_proc_word(op1+0, op2+0).action;
    instruction_image_size = 4;
  }

op test_m16i16(seg_ovrd: RSEG16, op1: MOFFS, op2: IMM16)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("test %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11011110111%s000%s%s%s", seg_ovrd.image, mod, rm, op1.image, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    test_proc_word(MEM[base+op1+1]::MEM[base+op1], op2+0).action;
    op1.action;
    instruction_image_size = 5;
  }

op test = test_r8r8   | test_m8r8   | test_r8i8   | test_m8i8
        | test_r16r16 | test_m16r16 | test_r16i16 | test_m16i16

// ==================================================================================
// and ops

op and_r8r8(op1: R8, op2: R8)
  init = {}
  syntax = format("and %s, %s", op1.syntax, op2.syntax)
  image = format("0010001011%s%s", op1.image, op2.image)
  action = {
    test_proc_byte(op1+0, op2+0).action;
    op1 = tmpb_res<0..7>;
    instruction_image_size = 2;
  }

op and_m8r8(seg_ovrd: RSEG16, op1: MOFFS, op2: R8)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("and %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11000100000%s%s%s%s", seg_ovrd.image, mod, op2.image, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    test_proc_byte(MEM[base+op1], op2+0).action;
    MEM[base+op1] = tmpb_res<0..7>;
    op1.action;
    instruction_image_size = 3;
  }

op and_r8m8(seg_ovrd: RSEG16, op1: R8, op2: MOFFS)
  init = { mod = 0b0; rm = 0b0; op2.init;}
  syntax = format("and %s, %s:%s", op1.syntax, seg_ovrd.syntax, op2.syntax)
  image = format("001%s11000100010%s%s%s%s", seg_ovrd.image, mod, op1.image, rm, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    test_proc_byte(MEM[base+op2], op1+0).action;
    op1 = tmpb_res<0..7>;
    op2.action;
    instruction_image_size = 3;
  }

op and_r16r16(op1: R16, op2: R16)
  init = {}
  syntax = format("and %s, %s", op1.syntax, op2.syntax)
  image = format("0010001111%s%s", op1.image, op2.image)
  action = {
    test_proc_word(op1+0, op2+0).action;
    op1 = tmpw_res<0..15>;
    instruction_image_size = 2;
  }

op and_m16r16(seg_ovrd: RSEG16, op1: MOFFS, op2: R16)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("and %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11000100001%s%s%s%s", seg_ovrd.image, mod, op2.image, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    test_proc_word(MEM[base+op1+1]::MEM[base+op1], op2+0).action;
    MEM[base+op1] = tmpw_res<0..7>;
    MEM[base+op1+1] = tmpw_res<8..15>;
    op1.action;
    instruction_image_size = 3;
  }

op and_r16m16(seg_ovrd: RSEG16, op1: R16, op2: MOFFS)
  init = { mod = 0b0; rm = 0b0; op2.init;}
  syntax = format("and %s, %s:%s", op1.syntax, seg_ovrd.syntax, op2.syntax)
  image = format("001%s11000100011%s%s%s%s", seg_ovrd.image, mod, op1.image, rm, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    test_proc_word(MEM[base+op2+1]::MEM[base+op2], op1+0).action;
    MEM[base+op2] = tmpw_res<0..7>;
    MEM[base+op2+1] = tmpw_res<8..15>;
    op2.action;
    instruction_image_size = 3;
  }

op and_r8i8(op1: R8, op2: IMM8)
  init = {}
  syntax = format("and %s, %s", op1.syntax, op2.syntax)
  image = format("1000000011000%s%s", op1.image, op2.image)
  action = {
    test_proc_byte(op1+0, op2+0).action;
    op1 = tmpb_res<0..7>;
    instruction_image_size = 3;
  }

op and_m8i8(seg_ovrd: RSEG16, op1: MOFFS, op2: IMM8)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("and %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11010000000%s000%s%s%s", seg_ovrd.image, mod, rm, op1.image, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    test_proc_byte(MEM[base+op1], op2+0).action;
    MEM[base+op1] = tmpb_res<0..7>;
    op1.action;
    instruction_image_size = 4;
  }

op and_r16i16(op1: R16, op2: IMM16)
  init = {}
  syntax = format("and %s, %s", op1.syntax, op2.syntax)
  image = format("1000000111000%s%s", op1.image, op2.image)
  action = {
    test_proc_word(op1+0, op2+0).action;
    op1 = tmpw_res<0..15>;
    instruction_image_size = 4;
  }

op and_m16i16(seg_ovrd: RSEG16, op1: MOFFS, op2: IMM16)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("and %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11010000001%s000%s%s%s", seg_ovrd.image, mod, rm, op1.image, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    test_proc_word(MEM[base+op1+1]::MEM[base+op1], op2+0).action;
    MEM[base+op1] = tmpw_res<0..7>;
    MEM[base+op1+1] = tmpw_res<8..15>;
    op1.action;
    instruction_image_size = 5;
  }

op and = and_r8r8   | and_m8r8   | and_r8m8   | and_r8i8   | and_m8i8
       | and_r16r16 | and_m16r16 | and_r16m16 | and_r16i16 | and_m16i16

// ==================================================================================
// or ops

internal op or_proc_byte(op1: BYTE, op2: BYTE)
  action = {
    tmpb_res = coerce(card(9), op1 | op2);
    CF = 0;
    OF = 0;
    SF = tmpb_res<7>;
    ZF = tmpb_res<0..7> == 0;
  }

internal op or_proc_word(op1: WORD, op2: WORD)
  action = {
    tmpw_res = coerce(card(17), op1 | op2);
    CF = 0;
    OF = 0;
    SF = tmpw_res<15>;
    ZF = tmpw_res<0..15> == 0;
  }

op or_r8r8(op1: R8, op2: R8)
  init = {}
  syntax = format("or %s, %s", op1.syntax, op2.syntax)
  image = format("0000101011%s%s", op1.image, op2.image)
  action = {
    or_proc_byte(op1+0, op2+0).action;
    op1 = tmpb_res<0..7>;
    instruction_image_size = 2;
  }

op or_m8r8(seg_ovrd: RSEG16, op1: MOFFS, op2: R8)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("or %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11000001000%s%s%s%s", seg_ovrd.image, mod, op2.image, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    or_proc_byte(MEM[base+op1], op2+0).action;
    MEM[base+op1] = tmpb_res<0..7>;
    op1.action;
    instruction_image_size = 3;
  }

op or_r8m8(seg_ovrd: RSEG16, op1: R8, op2: MOFFS)
  init = { mod = 0b0; rm = 0b0; op2.init;}
  syntax = format("or %s, %s:%s", op1.syntax, seg_ovrd.syntax, op2.syntax)
  image = format("001%s11000001010%s%s%s%s", seg_ovrd.image, mod, op1.image, rm, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    or_proc_byte(MEM[base+op2], op1+0).action;
    op1 = tmpb_res<0..7>;
    op2.action;
    instruction_image_size = 3;
  }

op or_r16r16(op1: R16, op2: R16)
  init = {}
  syntax = format("or %s, %s", op1.syntax, op2.syntax)
  image = format("0000101111%s%s", op1.image, op2.image)
  action = {
    or_proc_word(op1+0, op2+0).action;
    op1 = tmpw_res<0..15>;
    instruction_image_size = 2;
  }

op or_m16r16(seg_ovrd: RSEG16, op1: MOFFS, op2: R16)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("or %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11000001001%s%s%s%s", seg_ovrd.image, mod, op2.image, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    or_proc_word(MEM[base+op1+1]::MEM[base+op1], op2+0).action;
    MEM[base+op1] = tmpw_res<0..7>;
    MEM[base+op1+1] = tmpw_res<8..15>;
    op1.action;
    instruction_image_size = 3;
  }

op or_r16m16(seg_ovrd: RSEG16, op1: R16, op2: MOFFS)
  init = { mod = 0b0; rm = 0b0; op2.init;}
  syntax = format("or %s, %s:%s", op1.syntax, seg_ovrd.syntax, op2.syntax)
  image = format("001%s11000001011%s%s%s%s", seg_ovrd.image, mod, op1.image, rm, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    or_proc_word(MEM[base+op2+1]::MEM[base+op2], op1+0).action;
    MEM[base+op2] = tmpw_res<0..7>;
    MEM[base+op2+1] = tmpw_res<8..15>;
    op2.action;
    instruction_image_size = 3;
  }

op or_r8i8(op1: R8, op2: IMM8)
  init = {}
  syntax = format("or %s, %s", op1.syntax, op2.syntax)
  image = format("1000000011001%s%s", op1.image, op2.image)
  action = {
    or_proc_byte(op1+0, op2+0).action;
    op1 = tmpb_res<0..7>;
    instruction_image_size = 3;
  }

op or_m8i8(seg_ovrd: RSEG16, op1: MOFFS, op2: IMM8)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("or %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11010000000%s001%s%s%s", seg_ovrd.image, mod, rm, op1.image, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    or_proc_byte(MEM[base+op1], op2+0).action;
    MEM[base+op1] = tmpb_res<0..7>;
    op1.action;
    instruction_image_size = 4;
  }

op or_r16i16(op1: R16, op2: IMM16)
  init = {}
  syntax = format("or %s, %s", op1.syntax, op2.syntax)
  image = format("1000000111001%s%s", op1.image, op2.image)
  action = {
    or_proc_word(op1+0, op2+0).action;
    op1 = tmpw_res<0..15>;
    instruction_image_size = 4;
  }

op or_m16i16(seg_ovrd: RSEG16, op1: MOFFS, op2: IMM16)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("or %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11010000001%s001%s%s%s", seg_ovrd.image, mod, rm, op1.image, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    or_proc_word(MEM[base+op1+1]::MEM[base+op1], op2+0).action;
    MEM[base+op1] = tmpw_res<0..7>;
    MEM[base+op1+1] = tmpw_res<8..15>;
    op1.action;
    instruction_image_size = 5;
  }

op or = or_r8r8   | or_m8r8   | or_r8m8   | or_r8i8   | or_m8i8
      | or_r16r16 | or_m16r16 | or_r16m16 | or_r16i16 | or_m16i16

// ==================================================================================
// xor ops

internal op xor_proc_byte(op1: BYTE, op2: BYTE)
  action = {
    tmpb_res = coerce(card(9), op1 ^ op2);
    CF = 0;
    OF = 0;
    SF = tmpb_res<7>;
    ZF = tmpb_res<0..7> == 0;
  }

internal op xor_proc_word(op1: WORD, op2: WORD)
  action = {
    tmpw_res = coerce(card(17), op1 ^ op2);
    CF = 0;
    OF = 0;
    SF = tmpw_res<15>;
    ZF = tmpw_res<0..15> == 0;
  }

op xor_r8r8(op1: R8, op2: R8)
  init = {}
  syntax = format("xor %s, %s", op1.syntax, op2.syntax)
  image = format("0011001011%s%s", op1.image, op2.image)
  action = {
    xor_proc_byte(op1+0, op2+0).action;
    op1 = tmpb_res<0..7>;
    instruction_image_size = 2;
  }

op xor_m8r8(seg_ovrd: RSEG16, op1: MOFFS, op2: R8)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("xor %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11000110000%s%s%s%s", seg_ovrd.image, mod, op2.image, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    xor_proc_byte(MEM[base+op1], op2+0).action;
    MEM[base+op1] = tmpb_res<0..7>;
    op1.action;
    instruction_image_size = 3;
  }

op xor_r8m8(seg_ovrd: RSEG16, op1: R8, op2: MOFFS)
  init = { mod = 0b0; rm = 0b0; op2.init;}
  syntax = format("xor %s, %s:%s", op1.syntax, seg_ovrd.syntax, op2.syntax)
  image = format("001%s11000110010%s%s%s%s", seg_ovrd.image, mod, op1.image, rm, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    xor_proc_byte(MEM[base+op2], op1+0).action;
    op1 = tmpb_res<0..7>;
    op2.action;
    instruction_image_size = 3;
  }

op xor_r16r16(op1: R16, op2: R16)
  init = {}
  syntax = format("xor %s, %s", op1.syntax, op2.syntax)
  image = format("0011001111%s%s", op1.image, op2.image)
  action = {
    xor_proc_word(op1+0, op2+0).action;
    op1 = tmpw_res<0..15>;
    instruction_image_size = 2;
  }

op xor_m16r16(seg_ovrd: RSEG16, op1: MOFFS, op2: R16)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("xor %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11000110000%s%s%s%s", seg_ovrd.image, mod, op2.image, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    xor_proc_word(MEM[base+op1+1]::MEM[base+op1], op2+0).action;
    MEM[base+op1] = tmpw_res<0..7>;
    MEM[base+op1+1] = tmpw_res<8..15>;
    op1.action;
    instruction_image_size = 3;
  }

op xor_r16m16(seg_ovrd: RSEG16, op1: R16, op2: MOFFS)
  init = { mod = 0b0; rm = 0b0; op2.init;}
  syntax = format("xor %s, %s:%s", op1.syntax, seg_ovrd.syntax, op2.syntax)
  image = format("001%s11000110011%s%s%s%s", seg_ovrd.image, mod, op1.image, rm, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    xor_proc_word(MEM[base+op2+1]::MEM[base+op2], op1+0).action;
    MEM[base+op2] = tmpw_res<0..7>;
    MEM[base+op2+1] = tmpw_res<8..15>;
    op2.action;
    instruction_image_size = 3;
  }

op xor_r8i8(op1: R8, op2: IMM8)
  init = {}
  syntax = format("xor %s, %s", op1.syntax, op2.syntax)
  image = format("1000000011000%s%s", op1.image, op2.image)
  action = {
    xor_proc_byte(op1+0, op2+0).action;
    op1 = tmpb_res<0..7>;
    instruction_image_size = 3;
  }

op xor_m8i8(seg_ovrd: RSEG16, op1: MOFFS, op2: IMM8)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("xor %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11010000000%s000%s%s%s", seg_ovrd.image, mod, rm, op1.image, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    xor_proc_byte(MEM[base+op1], op2+0).action;
    MEM[base+op1] = tmpb_res<0..7>;
    op1.action;
    instruction_image_size = 4;
  }

op xor_r16i16(op1: R16, op2: IMM16)
  init = {}
  syntax = format("xor %s, %s", op1.syntax, op2.syntax)
  image = format("1000000111000%s%s", op1.image, op2.image)
  action = {
    xor_proc_word(op1+0, op2+0).action;
    op1 = tmpw_res<0..15>;
    instruction_image_size = 4;
  }

op xor_m16i16(seg_ovrd: RSEG16, op1: MOFFS, op2: IMM16)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("xor %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11010000001%s000%s%s%s", seg_ovrd.image, mod, rm, op1.image, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    xor_proc_word(MEM[base+op1+1]::MEM[base+op1], op2+0).action;
    MEM[base+op1] = tmpw_res<0..7>;
    MEM[base+op1+1] = tmpw_res<8..15>;
    op1.action;
    instruction_image_size = 5;
  }

op xor = xor_r8r8   | xor_m8r8   | xor_r8m8   | xor_r8i8   | xor_m8i8
       | xor_r16r16 | xor_m16r16 | xor_r16m16 | xor_r16i16 | xor_m16i16

// ==================================================================================
// not ops

op not_r8(op1: R8)
  init = {}
  syntax = format("not %s", op1.syntax)
  image = format("1111011011000%s", op1.image)
  action = {
    op1 = ~op1;
    instruction_image_size = 2;
  }

op not_m8(seg_ovrd: RSEG16, op1: MOFFS)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("not %s:%s", seg_ovrd.syntax, op1.syntax)
  image = format("001%s11011110110%s000%s%s", seg_ovrd.image, mod, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    MEM[base+op1] = ~MEM[base+op1];
    op1.action;
    instruction_image_size = 3;
  }

op not_r16(op1: R16)
  init = {}
  syntax = format("not %s", op1.syntax)
  image = format("1111011111000%s", op1.image)
  action = {
    op1 = ~op1;
    instruction_image_size = 2;
  }

op not_m16(seg_ovrd: RSEG16, op1: MOFFS)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("not %s:%s", seg_ovrd.syntax, op1.syntax)
  image = format("001%s11011110111%s000%s%s", seg_ovrd.image, mod, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    MEM[base+op1] = ~MEM[base+op1];
    MEM[base+op1+1] = ~MEM[base+op1+1];
    op1.action;
    instruction_image_size = 3;
  }

op not = not_r8 | not_m8 | not_r16 | not_m16

// ==================================================================================
// neg ops

internal op neg_proc_byte(op1: BYTE)
  action = {
    tmpb_res = coerce(card(9), 0 - op1);

    OF = op1<7> == 1 && tmpw_res<7> == 1;
    CF = op1 == 0;
    AF = (~op1<4> & tmpb_res<4>) | (op1<4> & ~tmpb_res<4>);
    SF = tmpb_res<7> == 1;
    ZF = tmpb_res<0..7> == 0;
  }

internal op neg_proc_word(op1: WORD)
  action = {
    tmpw_res = coerce(card(17), 0 - op1);

    OF = op1<15> == 1 && tmpw_res<15> == 1;
    CF = op1 == 0;
    AF = (~op1<4> & tmpw_res<4>) | (op1<4> & ~tmpw_res<4>);
    SF = tmpw_res<15> == 1;
    ZF = tmpw_res<0..15> == 0;
  }

op neg_r8(op1: R8)
  init = {}
  syntax = format("neg %s", op1.syntax)
  image = format("1111011011000%s", op1.image)
  action = {
    neg_proc_byte(op1+0).action;
    op1 = tmpb_res<0..7>;
    instruction_image_size = 2;
  }

op neg_m8(seg_ovrd: RSEG16, op1: MOFFS)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("neg %s:%s", seg_ovrd.syntax, op1.syntax)
  image = format("001%s11011110110%s000%s%s", seg_ovrd.image, mod, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    neg_proc_byte(MEM[base+op1]).action;
    MEM[base+op1] = tmpb_res<0..7>;
    op1.action;
    instruction_image_size = 3;
  }

op neg_r16(op1 : R16)
  init = {}
  syntax = format("neg %s", op1.syntax)
  image = format("1111011111000%s", op1.image)
  action = {
    neg_proc_word(op1+0).action;
    op1 = tmpw_res<0..15>;
    instruction_image_size = 2;
  }

op neg_m16(seg_ovrd: RSEG16, op1: MOFFS)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("neg %s:%s", seg_ovrd.syntax, op1.syntax)
  image = format("001%s11011110111%s000%s%s", seg_ovrd.image, mod, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    neg_proc_word(MEM[base+op1+1]::MEM[base+op1]).action;
    MEM[base+op1] = tmpw_res<0..7>;
    MEM[base+op1+1] = tmpw_res<8..15>;
    op1.action;
    instruction_image_size = 3;
  }

op neg = neg_r8 | neg_m8 | neg_r16 | neg_m16

// ==================================================================================
// cmp ops

op cmp_m8r8 (seg_ovrd: RSEG16, op1: MOFFS, op2: R8)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("cmp %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11000111000%s%s%s%s", seg_ovrd.image, mod, op2.image, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    sub_proc_byte(MEM[base+op1], op2 + 0).action;
    op1.action;
    instruction_image_size = 3;
  }

op cmp_m16r16 (seg_ovrd: RSEG16, op1: MOFFS, op2: R16)
  init = { mod = 0b0; rm = 0b0; op1.init;}
#ifdef I386_ASSEMBLER
  syntax = format("cmp word%s, %s", op1.syntax, op2.syntax)
#else
  syntax = format("cmp %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
#endif
  image = format("001%s11000111001%s%s%s%s", seg_ovrd.image, mod, op2.image, rm, op1.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    sub_proc_word(MEM[base+op1+1]::MEM[base+op1], op2+0).action;
    op1.action;
    instruction_image_size = 3;
  }

op cmp_r8r8 (op1: R8, op2: R8)
  init = {}
  syntax = format("cmp %s, %s", op1.syntax, op2.syntax)
  image = format("0011100011%s%s", op1.image, op2.image)
  action = {
    sub_proc_byte(op1+0, op2+0).action;
    instruction_image_size = 2;
  }

op cmp_r8m8 (seg_ovrd: RSEG16, op1: R8, op2: MOFFS)
  init = { mod = 0b0; rm = 0b0; op2.init;}
  syntax = format("cmp %s, %s:%s", op1.syntax, seg_ovrd.syntax, op2.syntax)
  image = format("001%s11000111010%s%s%s%s", seg_ovrd.image, mod, op1.image, rm, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    sub_proc_byte(op1+0, MEM[base+op2]).action;
    op2.action;
    instruction_image_size = 3;
  }

op cmp_r16r16 (op1: R16, op2: R16)
  init = {}
  syntax = format("cmp %s, %s", op1.syntax, op2.syntax)
  image = format("0011101111%s%s", op1.image, op2.image)
  action = {
    sub_proc_word(op1+0, op2+0).action;
    instruction_image_size = 2;
  }

op cmp_r16m16 (seg_ovrd: RSEG16, op1: R16, op2: MOFFS)
  init = { mod = 0b0; rm = 0b0; op2.init;}
#ifdef I386_ASSEMBLER
  syntax = format("cmp %s, word%s", op1.syntax, op2.syntax)
#else
  syntax = format("cmp %s, %s:%s", op1.syntax, seg_ovrd.syntax, op2.syntax)
#endif
  image = format("001%s11000111011%s%s%s%s", seg_ovrd.image, mod, op1.image, rm, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    sub_proc_word(op1+0, MEM[base+op2+1]::MEM[base+op2]).action;
    op2.action;
    instruction_image_size = 3;
  }

op cmp_r8i8 (op1: R8, op2: IMM8)
  init = {}
  syntax = format("cmp %s, %s", op1.syntax, op2.syntax)
  image = format("1000000011000%s%s", op1.image, op2.image)
  action = {
    sub_proc_byte(op1+0, op2+0).action;
    instruction_image_size = 3;
  }

op cmp_m8i8 (seg_ovrd: RSEG16, op1: MOFFS, op2: IMM8)
  init = { mod = 0b0; rm = 0b0; op1.init;}
  syntax = format("cmp %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
  image = format("001%s11010000000%s000%s%s%s", seg_ovrd.image, mod, rm, op1.image, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    sub_proc_byte(MEM[base+op1], op2+0).action;
    op1.action;
    instruction_image_size = 4;
  }

op cmp_r16i16 (op1: R16, op2: IMM16)
  init = {}
  syntax = format("cmp %s, %s", op1.syntax, op2.syntax)
  image = format("1000000111000%s%s", op1.image, op2.image)
  action = {
    sub_proc_word(op1+0, op2+0).action;
    instruction_image_size = 4;
  }

op cmp_m16i16 (seg_ovrd: RSEG16, op1: MOFFS, op2: IMM16)
  init = { mod = 0b0; rm = 0b0; op1.init;}
#ifdef I386_ASSEMBLER
  syntax = format("cmp word%s, %s", op1.syntax, op2.syntax)
#else
  syntax = format("cmp %s:%s, %s", seg_ovrd.syntax, op1.syntax, op2.syntax)
#endif
  image = format("001%s11010000001%s000%s%s%s", seg_ovrd.image, mod, rm, op1.image, op2.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    sub_proc_word(MEM[base+op1+1]::MEM[base+op1], op2+0).action;
    op1.action;
    instruction_image_size = 5;
  }

op cmp = cmp_m8r8   | cmp_r8r8   | cmp_r8m8   | cmp_r8i8   | cmp_m8i8
       | cmp_r16r16 | cmp_r16m16 | cmp_r16i16 | cmp_m16i16 | cmp_m16r16

// ==================================================================================
// Jump Instructions

op jmp_short(rel: SBYTE)
  init = {}
  syntax = format("jmp short %<label>d", rel)
  image  = format("11101011%s", rel)
  action = {
    IP = IP + coerce(WORD, rel);
    instruction_image_size = 2;
  }

op jmp_long(rel: SWORD)
  init = {}
  syntax = format("jmp %<label>d", rel)
  image  = format("11101001%s", rel<0..7>::rel<8..15>)
  action = {
    BRANCH = 1;
    NEXTPC = coerce(WORD, rel);
  }

op jmp_r16(rel: R16)
  init = {}
  syntax = format("jmp %s", rel.syntax)
  image  = format("1111111111000%s", rel.image)
  action = {
    IP = IP + rel;
    instruction_image_size = 2;
  }

op jmp_m16(seg_ovrd: RSEG16, rel: MOFFS)
  init = { mod = 0b0; rm = 0b0; rel.init;}
  syntax = format("jmp %s:%s", seg_ovrd.syntax, rel.syntax)
  image  = format("001%s11011111111%s000%s%s", seg_ovrd.image, mod, rm, rel.image)
  action = {
    base = coerce(addR, seg_ovrd) << 4;
    IP = IP + MEM[base+rel+1]::MEM[base+rel];
    rel.action;
    instruction_image_size = 3;
  }

op jmp = jmp_r16 | jmp_m16 | jmp_long | jmp_short

// ==================================================================================
// Conditional Jcc

op jo(rel: SBYTE)
  init = {}
  syntax = format("jo %<label>d", rel)
  image  = format("01110000%s", rel)
  action = {
    if OF == 1 then
      BRANCH = 1;
      NEXTPC = coerce(WORD, rel);
    else
      instruction_image_size = 2;
    endif;
  }

op jno(rel: SBYTE)
  init = {}
  syntax = format("jno %<label>d", rel)
  image  = format("01110001%s", rel)
  action = {
    if OF == 0 then
      BRANCH = 1;
      NEXTPC = coerce(WORD, rel);
    else
      instruction_image_size = 2;
    endif;
  }

op jc(rel: SBYTE)
  init = {}
  syntax = format("jc %<label>d", rel)
  image  = format("01110010%s", rel)
  action = {
    if CF == 1 then
      BRANCH = 1;
      NEXTPC = coerce(WORD, rel);
    else
      instruction_image_size = 2;
    endif;
  }

op jnc(rel: SBYTE)
  init = {}
  syntax = format("jnc %<label>d", rel)
  image  = format("01110011%s", rel)
  action = {
    if CF == 0 then
      BRANCH = 1;
      NEXTPC = coerce(WORD, rel);
    else
      instruction_image_size = 2;
    endif;
  }

op jz(rel: SBYTE)
  init = {}
  syntax = format("jz %<label>d", rel)
  image  = format("01110100%s", rel)
  action = {
    if ZF == 1 then
      BRANCH = 1;
      NEXTPC = coerce(WORD, rel);
    else
      instruction_image_size = 2;
    endif;
  }

op jnz(rel: SBYTE)
  init = {}
  syntax = format("jnz %<label>d", rel)
  image  = format("01110101%s", rel)
  action = {
    if ZF == 0 then
      BRANCH = 1;
      NEXTPC = coerce(WORD, rel);
    else
      instruction_image_size = 2;
    endif;
  }

op js(rel: SBYTE)
  init = {}
  syntax = format("js %<label>d", rel)
  image  = format("01111000%s", rel)
  action = {
    if SF == 1 then
      BRANCH = 1;
      NEXTPC = coerce(WORD, rel);
    else
      instruction_image_size = 2;
    endif;
  }

op jns(rel: SBYTE)
  init = {}
  syntax = format("jns %<label>d", rel)
  image  = format("01111001%s", rel)
  action = {
    if SF == 0 then
      BRANCH = 1;
      NEXTPC = coerce(WORD, rel);
    else
      instruction_image_size = 2;
    endif;
  }

op jp(rel: SBYTE)
  init = {}
  syntax = format("jp %<label>d", rel)
  image  = format("01111010%s", rel)
  action = {
    if PF == 1 then
      BRANCH = 1;
      NEXTPC = coerce(WORD, rel);
    else
      instruction_image_size = 2;
    endif;
  }

op jpe(rel: SBYTE)
  init = {}
  syntax = format("jpe %<label>d", rel)
  image  = format("01111010%s", rel)
  action = {
    if PF == 1 then
      BRANCH = 1;
      NEXTPC = coerce(WORD, rel);
    else
      instruction_image_size = 2;
    endif;
  }

op jnp(rel: SBYTE)
  init = {}
  syntax = format("jnp %<label>d", rel)
  image  = format("01111011%s", rel)
  action = {
    if PF == 0 then
      BRANCH = 1;
      NEXTPC = coerce(WORD, rel);
    else
      instruction_image_size = 2;
    endif;
  }

op jpo(rel: SBYTE)
  init = {}
  syntax = format("jpo %<label>d", rel)
  image  = format("01111011%s", rel)
  action = {
    if PF == 0 then
      BRANCH = 1;
      NEXTPC = coerce(WORD, rel);
    else
      instruction_image_size = 2;
    endif;
  }

op ja(rel: SBYTE)
  init = {}
  syntax = format("ja %<label>d", rel)
  image  = format("01110011%s", rel)
  action = {
    if CF == 0 && ZF == 0 then
      BRANCH = 1;
      NEXTPC = coerce(WORD, rel);
    else
      instruction_image_size = 2;
    endif;
  }

op jae(rel: SBYTE)
  init = {}
  syntax = format("jae %<label>d", rel)
  image  = format("01110011%s", rel)
  action = {
    if CF == 0 then
      BRANCH = 1;
      NEXTPC = coerce(WORD, rel);
    else
      instruction_image_size = 2;
    endif;
  }

op jb(rel: SBYTE)
  init = {}
  syntax = format("jb %<label>d", rel)
  image  = format("01110010%s", rel)
  action = {
    if CF == 1 then
      BRANCH = 1;
      NEXTPC = coerce(WORD, rel);
    else
      instruction_image_size = 2;
    endif;
  }

op jbe(rel: SBYTE)
  init = {}
  syntax = format("jbe %<label>d", rel)
  image  = format("01110110%s", rel)
  action = {
    if CF == 1 && ZF == 1 then
      BRANCH = 1;
      NEXTPC = coerce(WORD, rel);
    else
      instruction_image_size = 2;
    endif;
  }

op je(rel: SBYTE)
  init = {}
  syntax = format("je %<label>d", rel)
  image  = format("01110100%s", rel)
  action = {
    if ZF == 1 then
      BRANCH = 1;
      NEXTPC = coerce(WORD, rel);
    else
      instruction_image_size = 2;
    endif;
  }

op jne(rel: SBYTE)
  init = {}
  syntax = format("jne %<label>d", rel)
  image  = format("01110100%s", rel)
  action = {
    if ZF == 0 then
      BRANCH = 1;
      NEXTPC = coerce(WORD, rel);
    else
      instruction_image_size = 2;
    endif;
  }

op jna(rel: SBYTE)
  init = {}
  syntax = format("jna %<label>d", rel)
  image  = format("01110110%s", rel)
  action = {
    if CF == 1 && ZF == 1 then
      BRANCH = 1;
      NEXTPC = coerce(WORD, rel);
    else
      instruction_image_size = 2;
    endif;
  }

op jnae(rel: SBYTE)
  init = {}
  syntax = format("jnae %<label>d", rel)
  image  = format("01110010%s", rel)
  action = {
    if CF == 1 then
      BRANCH = 1;
      NEXTPC = coerce(WORD, rel);
    else
      instruction_image_size = 2;
    endif;
  }

op jnb(rel: SBYTE)
  init = {}
  syntax = format("jnb %<label>d", rel)
  image  = format("01110011%s", rel)
  action = {
    if CF == 0 then
      BRANCH = 1;
      NEXTPC = coerce(WORD, rel);
    else
      instruction_image_size = 2;
    endif;
  }

op jnbe(rel: SBYTE)
  init = {}
  syntax = format("jnbe %<label>d", rel)
  image  = format("01110111%s", rel)
  action = {
    if CF == 0 && ZF == 0 then
      BRANCH = 1;
      NEXTPC = coerce(WORD, rel);
    else
      instruction_image_size = 2;
    endif;
  }

op jg(rel: SBYTE)
  init = {}
  syntax = format("jg %<label>d", rel)
  image  = format("01111111%s", rel)
  action = {
    if ZF == 0 && SF == OF then
      BRANCH = 1;
      NEXTPC = coerce(WORD, rel);
    else
      instruction_image_size = 2;
    endif;
  }

op jge(rel: SBYTE)
  init = {}
  syntax = format("jge %<label>d", rel)
  image  = format("01111101%s", rel)
  action = {
    if SF == OF then
      BRANCH = 1;
      NEXTPC = coerce(WORD, rel);
    else
      instruction_image_size = 2;
    endif;
  }

op jl(rel: SBYTE)
  init = {}
  syntax = format("jl %<label>d", rel)
  image  = format("01111100%s", rel)
  action = {
    if SF != OF then
      BRANCH = 1;
      NEXTPC = coerce(WORD, rel);
    else
      instruction_image_size = 2;
    endif;
  }

op jle(rel: SBYTE)
  init = {}
  syntax = format("jle %<label>d", rel)
  image  = format("01111110%s", rel)
  action = {
    if ZF == 1 || SF != OF then
      BRANCH = 1;
      NEXTPC = coerce(WORD, rel);
    else
      instruction_image_size = 2;
    endif;
  }

op jng(rel: SBYTE)
  init = {}
  syntax = format("jng %<label>d", rel)
  image  = format("01111110%s", rel)
  action = {
    if ZF == 1 || SF != OF then
      BRANCH = 1;
      NEXTPC = coerce(WORD, rel);
    else
      instruction_image_size = 2;
    endif;
  }

op jnge(rel: SBYTE)
  init = {}
  syntax = format("jnge %<label>d", rel)
  image  = format("01111100%s", rel)
  action = {
    if SF != OF then
      BRANCH = 1;
      NEXTPC = coerce(WORD, rel);
    else
      instruction_image_size = 2;
    endif;
  }

op jnl(rel: SBYTE)
  init = {}
  syntax = format("jnl %<label>d", rel)
  image  = format("01111101%s", rel)
  action = {
    if SF == OF then
      BRANCH = 1;
      NEXTPC = coerce(WORD, rel);
    else
      instruction_image_size = 2;
    endif;
  }

op jnle(rel: SBYTE)
  init = {}
  syntax = format("jnle %<label>d", rel)
  image  = format("01111111%s", rel)
  action = {
    if ZF == 0 && SF == OF then
      BRANCH = 1;
      NEXTPC = coerce(WORD, rel);
    else
      instruction_image_size = 2;
    endif;
  }

// ==================================================================================

op int_(val: IMM16)
  init = {}
  syntax = format("int %s", val.syntax)
  image  = format("11001101%s", val.image)
  action = {
    instruction_image_size = 3;
    // TODO:
  }

op lea_r16label(op1: R16, rel: SWORD)
  init = {}
  syntax = format("lea %s, [%<label>d]", op1.syntax, rel)
  image  = format("10111%s%s", op1.image, rel)
  action = {
    op1 = coerce(WORD, rel);
    instruction_image_size = 3;
  }

op lea = lea_r16label

// ==================================================================================

op x86 = mov | xchg | add | sub | push | pop | mul | imul | div | idiv | pushA | popA | adc | sbb
       | inc | dec | test | and | xor | or | not | neg | cmp | jmp | jo | jno | jc | jnc | jz
       | jnz | js | jns | jp | jpe | jnp | jpo | ja | jae | jb | jbe | je | jne | jna | jnae | jnb
       | jnbe | jg | jge | jl | jle | jng | jnge | jnl | jnle | int_ | lea

// ==================================================================================

var jump_address  [WORD]
op instruction (operation: x86)
  syntax = operation.syntax
  image = operation.image
  init = {
    instruction_image_size = 0;
  }
  action = {
    BRANCH = 0;

    // IP must be synchonized with PC as PC can be externally modified.
    IP = program_counter<15..0>;

    operation.action;

    jump_address = NEXTPC;
    NEXTPC = coerce(WORD, 0);

    if (BRANCH == 1) then
      program_counter = (coerce(addR, CS) << 4) + coerce(addR, jump_address);
      IP = jump_address;
    else
      IP = IP + coerce(WORD, instruction_image_size);
      program_counter = (coerce(addR, CS) << 4) + coerce(addR, IP);
    endif;
  }

// ==================================================================================

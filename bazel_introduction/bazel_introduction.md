# Bazel: 概念と用語



## イントロダクション

Bzaelは、workspaceと呼ばれるディレクトリに構成されるソースコードから、ソフトウェアをビルドする。
ワークスペース内のソースコードは、パッケージの階層のネストにより構成されており、各パッケージは関連するソースファイルと、BUILDファイルが含まれるディレクトリである。
BUILdファイルは、ソフトウェアがビルドによって何を生成するかを示している。

## ワークスペース、パッケージ、ターゲット

### ワークスペース

ワークスペースはファイルシステム中のビルドしたいソフトウェアのソースコードが格納されているディレクトリであり、同様にビルドされた出力ファイルを含んでいるディレクトリへのリンクも同様である。
各ワークスペースディレクトリには、WORKSPACEというテキストファイルが格納されている。WORKSPACEファイルは、空のファイルか、出力ファイルをビルドするための外部依存が記述されている。

### パッケージ

ワークスペース中の基本となるコードの構成谷はパッケージである。
パッケージは、関連するファイルと依存関係を指定したファイルの一群である。

パッケージは、BUILDと呼ばれるファイルを含んでいるディレクトリとして定義され、WORKSPACEをトップディレクトリとして、その配下に配置される。
パッケージには、そのディレクトリに含まれる全てのファイルが含まれており、またサブディレクトリもパッケージの一部である。
しかし例外的にサブディレクトリのBUILDファイル自身はパッケージの一部ではない。

例えば、下記のファイルツリーの場合、

```
src/my/app/BUILD
src/my/app/app.cc
src/my/app/data/input.txt
src/my/app/tests/BUILD
src/my/app/tests/test.cc
```

2つのパッケージが含まれている。```my/app```と```my/app/tests```サブパッケージである。
```my/app/data```はパッケージではないが、```my/app```ディレクトリに属している。

### ターゲット

パッケージはコンテナである。
パッケージの各要素のことをターゲットと呼ぶ。
殆どのターゲットは、ファイルかルールのどちらかの種類として区別される。
加えて別のターゲットの種類として、パッケージグループが存在するが、これはあまり登場しない。

ファイルは大きく2種類に分類される。
ソースファイルは、一般的に人間によって書かれ、リポジトリにチェックインされる。
生成ファイルされたファイルはチェックインされないが、特定のルールに従ってソースファイルからビルドツールによって生成されるものである。

ターゲットの2番目の種類は、ルールである。
ルールは、入力ファイルと出力ファイルの関係を指定し、入力ファイルから出力ファイルを得るために必要なステップを含む。
ルールの出力は、常に生成されたファイルである。
ルールの入力は、おそらくはソースファイルであるが、生成ファイルも含まれることがある; つまり、ルールの出力は、他のルールの入力となることがあり、ルールによる長いチェインが構成されることがある。


Whether the input to a rule is a source file or a generated file is in most cases immaterial; what matters is only the contents of that file. This fact makes it easy to replace a complex source file with a generated file produced by a rule, such as happens when the burden of manually maintaining a highly structured file becomes too tiresome, and someone writes a program to derive it. No change is required to the consumers of that file. Conversely, a generated file may easily be replaced by a source file with only local changes.

ルールへの入力が、ソースファイルであるか生成ファイルであるかは、殆どの場合において重要ではない; 重要なのはファイルの中身である。
この事実により、膨大かつ構造化されたファイル群を手動で管理するのが非常に面倒な複雑なソースファイルを、ルールにより生成されたファイルに置き換えることとで、問題を簡単にする。xxx
このファイルの使用者は、何かをする必要はない。
逆に、生成されたファイルは、ローカルの変更のみでソースファイルへと簡単に置換することができる。

ルールへの入力に、他のルールが含まれていることがある。
このような関係性のより正確な意味は非常に複雑かつ言語、ルールに依存することであるが、直感的に考えると簡単なことである: C++ライブラリのルールAは、他のC++のライブラリのルールBを入力として持つ、ということである。
この依存関係の効果は、Aのコンパイル中にBのヘッダファイルが必要なときや、Aのリンク中にBのシンボルが必要な時やAを実行中にBのランタイムデータが使用可能になる、ということである。

全てのルールにおいて、共通して言えることは、ルールにより生成されたファイルは、ルール自身として、同一のパッケージに所属する、ということである; 生成したファイルを、他のパッケージに格納することはできない。
同様に、ルールの入力が他のパッケージから来ることもない。


パッケージグループは、特定のルールへのアクセス性を制限するための目的のパッケージ群である。
パッケージグループは、package_group関数により定義される。
これには、2つのプロパティが存在する: パッケージのリストと、パッケージの名前である。
これらを参照するための唯一の方法は、ルールのvisibility属性によるものか、package関数に属するdefault_visibility属性によるものである; これらはファイル自身を生成しない。
より詳細には、Build Encyclopediaの適切なセクションを参照すること。

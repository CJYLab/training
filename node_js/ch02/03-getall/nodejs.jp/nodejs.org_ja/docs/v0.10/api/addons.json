{
  &quot;source&quot;: &quot;doc/api/addons.markdown&quot;,
  &quot;modules&quot;: [
    {
      &quot;textRaw&quot;: &quot;Addons&quot;,
      &quot;name&quot;: &quot;addons&quot;,
      &quot;desc&quot;: &quot;<!--\nAddons are dynamically linked shared objects. They can provide glue to C and\nC++ libraries. The API (at the moment) is rather complex, involving\nknowledge of several libraries:\n-->\n\n<p>&#x30A2;&#x30C9;&#x30AA;&#x30F3;&#x306F;&#x52D5;&#x7684;&#x306B;&#x5171;&#x6709;&#x30AA;&#x30D6;&#x30B8;&#x30A7;&#x30AF;&#x30C8;&#x3092;&#x30EA;&#x30F3;&#x30AF;&#x3057;&#x307E;&#x3059;&#x3002;\n&#x305D;&#x308C;&#x3089;&#x306F;&#x3001;C &#x3084; C++ &#x306E;&#x30E9;&#x30A4;&#x30D6;&#x30E9;&#x30EA;&#x306B;&#x63A5;&#x5408;&#x70B9;&#x3092;&#x63D0;&#x4F9B;&#x3057;&#x307E;&#x3059;&#x3002;\nAPI &#x306F;&#x3044;&#x304F;&#x3064;&#x304B;&#x306E;&#x30E9;&#x30A4;&#x30D6;&#x30E9;&#x30EA;&#x306E;&#x77E5;&#x8B58;&#x304C;&#x5FC5;&#x8981;&#x3067;&#x3001;(&#x73FE;&#x6642;&#x70B9;&#x3067;&#x306F;) &#x304B;&#x306A;&#x308A;&#x8907;&#x96D1;&#x3067;&#x3059;&#x3002;\n\n</p>\n<!--\n - V8 JavaScript, a C++ library. Used for interfacing with JavaScript:\n   creating objects, calling functions, etc.  Documented mostly in the\n   `v8.h` header file (`deps/v8/include/v8.h` in the Node source\n   tree), which is also available\n   [online](http://izs.me/v8-docs/main.html).\n-->\n\n<ul>\n<li>V8 JavaScript &#x306F; C++ &#x306E;&#x30E9;&#x30A4;&#x30D6;&#x30E9;&#x30EA;&#x3067;&#x3059;&#x3002;\nJavaScript &#x306E;&#x30AA;&#x30D6;&#x30B8;&#x30A7;&#x30AF;&#x30C8;&#x4F5C;&#x6210;&#x3084;&#x95A2;&#x6570;&#x547C;&#x3073;&#x51FA;&#x3057;&#x7B49;&#x306E;&#x30A4;&#x30F3;&#x30BF;&#x30D5;&#x30A7;&#x30FC;&#x30B9;&#x306B;&#x4F7F;&#x7528;&#x3055;&#x308C;&#x307E;&#x3059;&#x3002;\n&#x30C9;&#x30AD;&#x30E5;&#x30E1;&#x30F3;&#x30C8;&#x306F;&#x4E3B;&#x306B;&#x3001;<code>v8.h</code> &#x306E;&#x30D8;&#x30C3;&#x30C0;&#x30D5;&#x30A1;&#x30A4;&#x30EB;\n(Node &#x306E;&#x30BD;&#x30FC;&#x30B9;&#x30C4;&#x30EA;&#x30FC;&#x306E;&#x4E2D;&#x306E; <code>deps/v8/include/v8.h</code>) &#x306B;&#x8A18;&#x3055;&#x308C;&#x3066;&#x3044;&#x307E;&#x3059;&#x304C;&#x3001;\n<a href="\&quot;http://izs.me/v8-docs/main.html\&quot;">&#x30AA;&#x30F3;&#x30E9;&#x30A4;&#x30F3;</a> &#x3067;&#x53C2;&#x7167;&#x3059;&#x308B;&#x3053;&#x3068;&#x3082;&#x3067;&#x304D;&#x307E;&#x3059;&#x3002;</li>\n</ul>\n<!--\n - [libuv](https://github.com/joyent/libuv), C event loop library.\n   Anytime one needs to wait for a file descriptor to become readable,\n   wait for a timer, or wait for a signal to be received one will need\n   to interface with libuv. That is, if you perform any I/O, libuv will\n   need to be used.\n-->\n\n<ul>\n<li><a href="\&quot;https://github.com/joyent/libuv\&quot;">libuv</a> &#x306F;\nC &#x306E;&#x30A4;&#x30D9;&#x30F3;&#x30C8;&#x30EB;&#x30FC;&#x30D7;&#x30E9;&#x30A4;&#x30D6;&#x30E9;&#x30EA;&#x3067;&#x3059;&#x3002;\n&#x30D5;&#x30A1;&#x30A4;&#x30EB;&#x8A18;&#x8FF0;&#x5B50;&#x304C;&#x8AAD;&#x307F;&#x53D6;&#x308A;&#x53EF;&#x80FD;&#x306B;&#x306A;&#x308B;&#x306E;&#x3092;&#x5F85;&#x3064;&#x3068;&#x304D;&#x3001;&#x30BF;&#x30A4;&#x30DE;&#x30FC;&#x3092;&#x5F85;&#x3064;&#x3068;&#x304D;&#x3001;\n&#x30B7;&#x30B0;&#x30CA;&#x30EB;&#x3092;&#x53D7;&#x4FE1;&#x3059;&#x308B;&#x306E;&#x3092;&#x5F85;&#x3064;&#x3068;&#x304D;&#x306F;&#x3044;&#x3064;&#x3067;&#x3082;&#x3001;\nlibv &#x306E;&#x30A4;&#x30F3;&#x30BF;&#x30D5;&#x30A7;&#x30FC;&#x30B9;&#x304C;&#x5FC5;&#x8981;&#x306B;&#x306A;&#x308A;&#x307E;&#x3059;&#x3002;\n&#x3064;&#x307E;&#x308A;&#x3001;&#x4F55;&#x3089;&#x304B;&#x306E; I/O &#x51E6;&#x7406;&#x3092;&#x3059;&#x308B;&#x3068;&#x5FC5;&#x305A; libuv &#x3092;&#x4F7F;&#x3046;&#x5FC5;&#x8981;&#x304C;&#x3042;&#x308B;&#x3068;&#x3044;&#x3046;&#x3053;&#x3068;&#x3067;&#x3059;&#x3002;</li>\n</ul>\n<!--\n - Internal Node libraries. Most importantly is the `node::ObjectWrap`\n   class which you will likely want to derive from.\n-->\n\n<ul>\n<li>Node &#x306E;&#x5185;&#x90E8;&#x30E9;&#x30A4;&#x30D6;&#x30E9;&#x30EA;&#x3002;\n&#x3082;&#x3063;&#x3068;&#x3082;&#x91CD;&#x8981;&#x306A;&#x306E;&#x306F; <code>node::ObjectWrap</code> &#x30AF;&#x30E9;&#x30B9;&#x3067;&#x3001;\n&#x3053;&#x306E;&#x30AF;&#x30E9;&#x30B9;&#x304B;&#x3089;&#x6D3E;&#x751F;&#x3055;&#x305B;&#x308B;&#x3053;&#x3068;&#x304C;&#x591A;&#x304F;&#x306A;&#x308B;&#x3067;&#x3057;&#x3087;&#x3046;&#x3002;</li>\n</ul>\n<!--\n - Others. Look in `deps/` for what else is available.\n-->\n\n<ul>\n<li>&#x305D;&#x306E;&#x4ED6;&#x3002;&#x3069;&#x306E;&#x3088;&#x3046;&#x306A;&#x7269;&#x304C;&#x5229;&#x7528;&#x3067;&#x304D;&#x308B;&#x304B;&#x306F; <code>deps/</code> &#x4EE5;&#x4E0B;&#x3092;&#x53C2;&#x7167;&#x3057;&#x3066;&#x3055;&#x3044;&#x3002;</li>\n</ul>\n<!--\nNode statically compiles all its dependencies into the executable.\nWhen compiling your module, you don't need to worry about linking to\nany of these libraries.\n-->\n\n<p>Node &#x306F;&#x5168;&#x3066;&#x306E;&#x4F9D;&#x5B58;&#x30E9;&#x30A4;&#x30D6;&#x30E9;&#x30EA;&#x3092;&#x5B9F;&#x884C;&#x30D5;&#x30A1;&#x30A4;&#x30EB;&#x306B;&#x9759;&#x7684;&#x306B;&#x30B3;&#x30F3;&#x30D1;&#x30A4;&#x30EB;&#x3057;&#x307E;&#x3059;&#x3002;\n&#x30E2;&#x30B8;&#x30E5;&#x30FC;&#x30EB;&#x306E;&#x30B3;&#x30F3;&#x30D1;&#x30A4;&#x30EB;&#x6642;&#x306B;&#x306F;&#x3001;&#x305D;&#x308C;&#x3089;&#x306E;&#x30EA;&#x30F3;&#x30AF;&#x306B;&#x3064;&#x3044;&#x3066;&#x4E00;&#x5207;&#x6C17;&#x306B;&#x3059;&#x308B;&#x5FC5;&#x8981;&#x306F;&#x6709;&#x308A;&#x307E;&#x305B;&#x3093;&#x3002;\n\n</p>\n<!--\nAll of the following examples are available for\n[download](https://github.com/rvagg/node-addon-examples) and may be\nused as a starting-point for your own Addon.\n-->\n\n<p>&#x4EE5;&#x4E0B;&#x306E;&#x30B5;&#x30F3;&#x30D7;&#x30EB;&#x306E;&#x5168;&#x3066;&#x306F;\n<a href="\&quot;https://github.com/rvagg/node-addon-examples\&quot;">&#x30C0;&#x30A6;&#x30F3;&#x30ED;&#x30FC;&#x30C9;</a>\n&#x304B;&#x3089;&#x5229;&#x7528;&#x3059;&#x308B;&#x3053;&#x3068;&#x304C;&#x3067;&#x304D;&#x3001;&#x72EC;&#x81EA;&#x306E;&#x30A2;&#x30C9;&#x30AA;&#x30F3;&#x306E;&#x51FA;&#x767A;&#x70B9;&#x306B;&#x306A;&#x308B;&#x3067;&#x3057;&#x3087;&#x3046;&#x3002;\n\n</p>\n&quot;,
      &quot;modules&quot;: [
        {
          &quot;textRaw&quot;: &quot;Hello world&quot;,
          &quot;name&quot;: &quot;hello_world&quot;,
          &quot;desc&quot;: &quot;<!--\nTo get started let's make a small Addon which is the C++ equivalent of\nthe following JavaScript code:\n-->\n\n<p>&#x3067;&#x306F;&#x3001; &#x4EE5;&#x4E0B;&#x306E; JavaScript &#x30B3;&#x30FC;&#x30C9;&#x3068;&#x540C;&#x3058;&#x69D8;&#x306B;&#x52D5;&#x4F5C;&#x3059;&#x308B;&#x5C0F;&#x3055;&#x306A;&#x30A2;&#x30C9;&#x30AA;&#x30F3;&#x3092;\nC++ &#x3067;&#x4F5C;&#x6210;&#x3057;&#x3066;&#x307F;&#x307E;&#x3057;&#x3087;&#x3046;&#x3002;\n\n</p>\n<pre><code>module.exports.hello = function() { return &apos;world&apos;; };</code></pre>\n<!--\nFirst we create a file `hello.cc`:\n-->\n\n<p>&#x6700;&#x521D;&#x306B; <code>hello.cc</code> &#x3068;&#x3044;&#x3046;&#x30D5;&#x30A1;&#x30A4;&#x30EB;&#x3092;&#x4F5C;&#x6210;&#x3057;&#x307E;&#x3059;:\n\n\n</p>\n<pre><code>#include &lt;node.h&gt;\n#include &lt;v8.h&gt;\n\nusing namespace v8;\n\nHandle&lt;Value&gt; Method(const Arguments&amp; args) {\n  HandleScope scope;\n  return scope.Close(String::New(&quot;world&quot;));\n}\n\nvoid init(Handle&lt;Object&gt; exports) {\n  exports-&gt;Set(String::NewSymbol(&quot;hello&quot;),\n      FunctionTemplate::New(Method)-&gt;GetFunction());\n}\n\nNODE_MODULE(hello, init)</code></pre>\n<!--\nNote that all Node addons must export an initialization function:\n-->\n\n<p>&#x5168;&#x3066;&#x306E; Node &#x30A2;&#x30C9;&#x30AA;&#x30F3;&#x306F;&#x521D;&#x671F;&#x5316;&#x95A2;&#x6570;&#x3092;&#x30A8;&#x30AF;&#x30B9;&#x30DD;&#x30FC;&#x30C8;&#x3057;&#x306A;&#x3051;&#x308C;&#x3070;&#x306A;&#x3089;&#x306A;&#x3044;&#x3053;&#x3068;&#x306B;\n&#x6CE8;&#x610F;&#x3057;&#x3066;&#x304F;&#x3060;&#x3055;&#x3044;&#x3002;\n\n</p>\n<pre><code>void Initialize (Handle&lt;Object&gt; exports);\nNODE_MODULE(module_name, Initialize)</code></pre>\n<!--\nThere is no semi-colon after `NODE_MODULE` as it's not a function (see `node.h`).\n\nThe `module_name` needs to match the filename of the final binary (minus the\n.node suffix).\n\nThe source code needs to be built into `hello.node`, the binary Addon. To\ndo this we create a file called `binding.gyp` which describes the configuration\nto build your module in a JSON-like format. This file gets compiled by\n[node-gyp](https://github.com/TooTallNate/node-gyp).\n-->\n\n<p><code>NODE_MODULE</code> &#x306F;&#x95A2;&#x6570;&#x3067;&#x306F;&#x306A;&#x3044;&#x306E;&#x3067;&#x3001;&#x305D;&#x306E;&#x5F8C;&#x306B;&#x30BB;&#x30DF;&#x30B3;&#x30ED;&#x30F3;&#x3092;&#x4ED8;&#x3051;&#x3066;&#x306F;&#x3044;&#x3051;&#x307E;&#x305B;&#x3093;\n(<code>node.h</code> &#x3092;&#x53C2;&#x7167;&#x3057;&#x3066;&#x304F;&#x3060;&#x3055;&#x3044;)&#x3002;\n\n</p>\n<p><code>module_name</code> &#x306F;&#x6700;&#x7D42;&#x7684;&#x306A;&#x30D0;&#x30A4;&#x30CA;&#x30EA;&#x306E;&#x30D5;&#x30A1;&#x30A4;&#x30EB;&#x540D; (&#x62E1;&#x5F35;&#x5B50; .node &#x3092;&#x9664;&#x304F;)\n&#x3068;&#x30DE;&#x30C3;&#x30C1;&#x3059;&#x308B;&#x5FC5;&#x8981;&#x304C;&#x3042;&#x308A;&#x307E;&#x3059;&#x3002;\n\n</p>\n<p>&#x3053;&#x306E;&#x30BD;&#x30FC;&#x30B9;&#x30B3;&#x30FC;&#x30C9;&#x306F;&#x3001;<code>hello.node</code> &#x3068;&#x3044;&#x3046;&#x30D0;&#x30A4;&#x30CA;&#x30EA;&#x30A2;&#x30C9;&#x30AA;&#x30F3;&#x3068;&#x3057;&#x3066;&#x30D3;&#x30EB;&#x30C9;&#x3055;&#x308C;&#x308B;&#x5FC5;&#x8981;&#x304C;&#x6709;&#x308A;&#x307E;&#x3059;&#x3002;\n&#x305D;&#x306E;&#x305F;&#x3081;&#x306B; <code>binding.gyp</code> &#x3068;&#x547C;&#x3070;&#x308C;&#x308B;&#x3001;&#x3042;&#x306A;&#x305F;&#x306E;&#x30E2;&#x30B8;&#x30E5;&#x30FC;&#x30EB;&#x3092;&#x30D3;&#x30EB;&#x30C9;&#x3059;&#x308B;&#x305F;&#x3081;&#x306E;\n&#x69CB;&#x6210;&#x3092; JSON &#x7684;&#x306A;&#x30D5;&#x30A9;&#x30FC;&#x30DE;&#x30C3;&#x30C8;&#x3067;&#x8A18;&#x8FF0;&#x3057;&#x305F;&#x30D5;&#x30A1;&#x30A4;&#x30EB;&#x3092;&#x4F5C;&#x6210;&#x3057;&#x307E;&#x3059;&#x3002;\n&#x3053;&#x306E;&#x30D5;&#x30A1;&#x30A4;&#x30EB;&#x306F; <a href="\&quot;https://github.com/TooTallNate/node-gyp\&quot;">node-gyp</a>\n&#x306B;&#x3088;&#x3063;&#x3066;&#x30B3;&#x30F3;&#x30D1;&#x30A4;&#x30EB;&#x3055;&#x308C;&#x307E;&#x3059;&#x3002;\n\n</p>\n<pre><code>{\n  &quot;targets&quot;: [\n    {\n      &quot;target_name&quot;: &quot;hello&quot;,\n      &quot;sources&quot;: [ &quot;hello.cc&quot; ]\n    }\n  ]\n}</code></pre>\n<!--\nThe next step is to generate the appropriate project build files for the\ncurrent platform. Use `node-gyp configure` for that.\n-->\n\n<p>&#x6B21;&#x306E;&#x30B9;&#x30C6;&#x30C3;&#x30D7;&#x306F;&#x73FE;&#x5728;&#x306E;&#x30D7;&#x30E9;&#x30C3;&#x30C8;&#x30D5;&#x30A9;&#x30FC;&#x30E0;&#x306B;&#x9069;&#x3057;&#x305F;&#x30D7;&#x30ED;&#x30B8;&#x30A7;&#x30AF;&#x30C8;&#x30D3;&#x30EB;&#x30C9;&#x30D5;&#x30A1;&#x30A4;&#x30EB;&#x3092;\n&#x751F;&#x6210;&#x3059;&#x308B;&#x3053;&#x3068;&#x3067;&#x3059;&#x3002;\n<code>node-gyp configure</code> &#x3092;&#x4F7F;&#x3044;&#x307E;&#x3059;&#x3002;\n\n</p>\n<!--\nNow you will have either a `Makefile` (on Unix platforms) or a `vcxproj` file\n(on Windows) in the `build/` directory. Next invoke the `node-gyp build`\ncommand.\n-->\n\n<p>&#x3053;&#x308C;&#x3067;&#x3001;<code>Makefile</code> (Unix &#x30D7;&#x30E9;&#x30C3;&#x30C8;&#x30D5;&#x30A9;&#x30FC;&#x30E0;&#x306E;&#x5834;&#x5408;)&#x3001;&#x307E;&#x305F;&#x306F; <code>vcxproj</code> &#x30D5;&#x30A1;&#x30A4;&#x30EB;\n(Windows &#x306E;&#x5834;&#x5408;) &#x304C; <code>build/</code> &#x30C7;&#x30A3;&#x30EC;&#x30AF;&#x30C8;&#x30EA;&#x306B;&#x4F5C;&#x3089;&#x308C;&#x307E;&#x3059;&#x3002;\n&#x6B21;&#x306B; <code>node-gyp build</code> &#x30B3;&#x30DE;&#x30F3;&#x30C9;&#x3092;&#x8D77;&#x52D5;&#x3057;&#x307E;&#x3059;&#x3002;\n\n</p>\n<!--\nNow you have your compiled `.node` bindings file! The compiled bindings end up\nin `build/Release/`.\n-->\n\n<p>&#x3053;&#x308C;&#x3067;&#x30B3;&#x30F3;&#x30D1;&#x30A4;&#x30EB;&#x3055;&#x308C;&#x305F; <code>.node</code> &#x30D0;&#x30A4;&#x30F3;&#x30C7;&#x30A3;&#x30F3;&#x30B0;&#x30D5;&#x30A1;&#x30A4;&#x30EB;&#x304C;&#x4F5C;&#x6210;&#x3055;&#x308C;&#x307E;&#x3059;&#xFF01;\n&#x30B3;&#x30F3;&#x30D1;&#x30A4;&#x30EB;&#x3055;&#x308C;&#x305F;&#x30D0;&#x30A4;&#x30F3;&#x30C7;&#x30A3;&#x30F3;&#x30B0;&#x30D5;&#x30A1;&#x30A4;&#x30EB;&#x306F; <code>build/Release/</code> &#x306B;&#x3042;&#x308A;&#x307E;&#x3059;&#x3002;\n\n</p>\n<!--\nYou can now use the binary addon in a Node project `hello.js` by pointing `require` to\nthe recently built `hello.node` module:\n-->\n\n<p>&#x30D3;&#x30EB;&#x30C9;&#x3055;&#x308C;&#x305F; <code>hello.node</code> &#x30E2;&#x30B8;&#x30E5;&#x30FC;&#x30EB;&#x3092; <code>require</code> &#x3067;&#x6307;&#x5B9A;&#x3059;&#x308B;&#x3053;&#x3068;&#x306B;&#x3088;&#x308A;&#x3001;\n&#x3053;&#x306E;&#x30D0;&#x30A4;&#x30CA;&#x30EA;&#x30A2;&#x30C9;&#x30AA;&#x30F3;&#x3092; Node &#x30D7;&#x30ED;&#x30B8;&#x30A7;&#x30AF;&#x30C8;&#x306E; <code>hello.js</code> &#x304B;&#x3089;&#x5229;&#x7528;&#x3059;&#x308B;&#x3053;&#x3068;&#x304C;\n&#x53EF;&#x80FD;&#x306B;&#x306A;&#x308A;&#x307E;&#x3059;&#x3002;\n\n</p>\n<pre><code>var addon = require(&apos;./build/Release/hello&apos;);\n\nconsole.log(addon.hello()); // &apos;world&apos;</code></pre>\n<!--\nPlease see patterns below for further information or\n<https://github.com/arturadib/node-qt> for an example in production.\n-->\n\n<p>&#x3055;&#x3089;&#x306B;&#x8A73;&#x3057;&#x3044;&#x60C5;&#x5831;&#x306B;&#x3064;&#x3044;&#x3066;&#x306F;&#x4E0B;&#x8A18;&#x306E;&#x30D1;&#x30BF;&#x30FC;&#x30F3;&#x304B;&#x3001;\n</p>\n<p><a href="\&quot;https://github.com/arturadib/node-qt\&quot;">https://github.com/arturadib/node-qt</a> &#x3092;&#x5B9F;&#x969B;&#x306E;&#x30D7;&#x30ED;&#x30C0;&#x30AF;&#x30C8;&#x306B;&#x304A;&#x3051;&#x308B;\n&#x4F8B;&#x3068;&#x3057;&#x3066;&#x53C2;&#x7167;&#x3057;&#x3066;&#x304F;&#x3060;&#x3055;&#x3044;&#x3002;\n\n</p>\n&quot;,
          &quot;type&quot;: &quot;module&quot;,
          &quot;displayName&quot;: &quot;Hello world&quot;
        },
        {
          &quot;textRaw&quot;: &quot;Addon patterns&quot;,
          &quot;name&quot;: &quot;addon_patterns&quot;,
          &quot;desc&quot;: &quot;<!--\nBelow are some addon patterns to help you get started. Consult the online\n[v8 reference](http://izs.me/v8-docs/main.html) for help with the various v8\ncalls, and v8's [Embedder's Guide](http://code.google.com/apis/v8/embed.html)\nfor an explanation of several concepts used such as handles, scopes,\nfunction templates, etc.\n-->\n\n<p>&#x4EE5;&#x4E0B;&#x306F;&#x521D;&#x5FC3;&#x8005;&#x306B;&#x5F79;&#x7ACB;&#x3064;&#x30A2;&#x30C9;&#x30AA;&#x30F3;&#x306E;&#x30D1;&#x30BF;&#x30FC;&#x30F3;&#x3067;&#x3059;&#x3002;\nv8 &#x306E;&#x69D8;&#x3005;&#x306A; API &#x306B;&#x3064;&#x3044;&#x3066;&#x306F;&#x30AA;&#x30F3;&#x30E9;&#x30A4;&#x30F3;&#x306E;\n<a href="\&quot;http://izs.me/v8-docs/main.html\&quot;">v8 reference</a> &#x304C;&#x3001;\n&#x305D;&#x3057;&#x3066; &#x30CF;&#x30F3;&#x30C9;&#x30EB;&#x3084;&#x30B9;&#x30B3;&#x30FC;&#x30D7;&#x3001;&#x95A2;&#x6570;&#x30C6;&#x30F3;&#x30D7;&#x30EC;&#x30FC;&#x30C8;&#x306A;&#x3069;&#x3044;&#x304F;&#x3064;&#x304B;&#x306E;&#x6982;&#x5FF5;&#x306B;&#x3064;&#x3044;&#x3066;&#x306F;\nv8 &#x306E; <a href="\&quot;http://code.google.com/apis/v8/embed.html\&quot;">Embedder&apos;s Guide</a> &#x304C;\n&#x5F79;&#x306B;&#x7ACB;&#x3064;&#x3067;&#x3057;&#x3087;&#x3046;&#x3002;\n\n</p>\n<!--\nIn order to use these examples you need to compile them using `node-gyp`.\nCreate the following `binding.gyp` file:\n-->\n\n<p>&#x3053;&#x306E;&#x30B5;&#x30F3;&#x30D7;&#x30EB;&#x3092;&#x5229;&#x7528;&#x3067;&#x304D;&#x308B;&#x3088;&#x3046;&#x306B;&#x3059;&#x308B;&#x306B;&#x306F;&#x3001;<code>node-gyp</code> &#x3092;&#x4F7F;&#x7528;&#x3057;&#x3066;\n&#x30B3;&#x30F3;&#x30D1;&#x30A4;&#x30EB;&#x3059;&#x308B;&#x5FC5;&#x8981;&#x304C;&#x3042;&#x308A;&#x307E;&#x3059;&#x3002;\n&#x4EE5;&#x4E0B;&#x306E; <code>binding.gyp</code> &#x30D5;&#x30A1;&#x30A4;&#x30EB;&#x3092;&#x4F5C;&#x6210;&#x3057;&#x307E;&#x3059;&#x3002;\n\n</p>\n<pre><code>{\n  &quot;targets&quot;: [\n    {\n      &quot;target_name&quot;: &quot;addon&quot;,\n      &quot;sources&quot;: [ &quot;addon.cc&quot; ]\n    }\n  ]\n}</code></pre>\n<!--\nIn cases where there is more than one `.cc` file, simply add the file name to the\n`sources` array, e.g.:\n-->\n\n<p>&#x4E00;&#x3064;&#x4EE5;&#x4E0A;&#x306E; <code>.cc</code> &#x30D5;&#x30A1;&#x30A4;&#x30EB;&#x304C;&#x3042;&#x308B;&#x5834;&#x5408;&#x306F;&#x3001;&#x5358;&#x7D14;&#x306B; <code>sources</code> &#x914D;&#x5217;&#x306B;&#x30D5;&#x30A1;&#x30A4;&#x30EB;&#x540D;&#x3092;\n&#x52A0;&#x3048;&#x308B;&#x3060;&#x3051;&#x3067;&#x3059;&#x3002;&#x4F8B;:\n\n</p>\n<pre><code>&quot;sources&quot;: [&quot;addon.cc&quot;, &quot;myexample.cc&quot;]</code></pre>\n<!--\nNow that you have your `binding.gyp` ready, you can configure and build the\naddon:\n-->\n\n<p>&#x3053;&#x308C;&#x3067; <code>binding.gyp</code> &#x306E;&#x6E96;&#x5099;&#x304C;&#x3067;&#x304D;&#x307E;&#x3057;&#x305F;&#x3002;\n&#x30A2;&#x30C9;&#x30AA;&#x30F3;&#x3092;&#x30B3;&#x30F3;&#x30D5;&#x30A3;&#x30AE;&#x30E5;&#x30A2;&#x304A;&#x3088;&#x3073;&#x30D3;&#x30EB;&#x30C9;&#x3059;&#x308B;&#x306B;&#x306F;:\n\n</p>\n<pre><code>$ node-gyp configure build</code></pre>\n&quot;,
          &quot;modules&quot;: [
            {
              &quot;textRaw&quot;: &quot;Function arguments&quot;,
              &quot;name&quot;: &quot;function_arguments&quot;,
              &quot;desc&quot;: &quot;<!--\nThe following pattern illustrates how to read arguments from JavaScript\nfunction calls and return a result. This is the main and only needed source\n`addon.cc`:\n-->\n\n<p>&#x4EE5;&#x4E0B;&#x306E;&#x30D1;&#x30BF;&#x30FC;&#x30F3;&#x306F; JavaScript &#x304B;&#x3089;&#x547C;&#x3073;&#x51FA;&#x3055;&#x308C;&#x305F;&#x95A2;&#x6570;&#x3067;&#x5F15;&#x6570;&#x3092;&#x8AAD;&#x307F;&#x51FA;&#x3057;&#x305F;&#x308A;&#x3001;\n&#x7D50;&#x679C;&#x3092;&#x8FD4;&#x3059;&#x65B9;&#x6CD5;&#x3092;&#x793A;&#x3057;&#x307E;&#x3059;&#x3002;&#x3053;&#x308C;&#x306F; <code>addon.cc</code> &#x3067;&#x306E;&#x307F;&#x5FC5;&#x8981;&#x3068;&#x306A;&#x308A;&#x307E;&#x3059;&#x3002;\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#include &lt;node.h&gt;\n\nusing namespace v8;\n\nHandle&lt;Value&gt; Add(const Arguments&amp; args) {\n  HandleScope scope;\n\n  if (args.Length() &lt; 2) {\n    ThrowException(Exception::TypeError(String::New(&quot;Wrong number of arguments&quot;)));\n    return scope.Close(Undefined());\n  }\n\n  if (!args[0]-&gt;IsNumber() || !args[1]-&gt;IsNumber()) {\n    ThrowException(Exception::TypeError(String::New(&quot;Wrong arguments&quot;)));\n    return scope.Close(Undefined());\n  }\n\n  Local&lt;Number&gt; num = Number::New(args[0]-&gt;NumberValue() +\n      args[1]-&gt;NumberValue());\n  return scope.Close(num);\n}\n\nvoid Init(Handle&lt;Object&gt; exports) {\n  exports-&gt;Set(String::NewSymbol(&quot;add&quot;),\n      FunctionTemplate::New(Add)-&gt;GetFunction());\n}\n\nNODE_MODULE(addon, Init)</code></pre>\n<!--\nYou can test it with the following JavaScript snippet:\n-->\n\n<p>&#x4EE5;&#x4E0B;&#x306E; JavaScript &#x30B3;&#x30FC;&#x30C9;&#x7247;&#x3067;&#x30C6;&#x30B9;&#x30C8;&#x3059;&#x308B;&#x3053;&#x3068;&#x304C;&#x3067;&#x304D;&#x307E;&#x3059;&#x3002;\n\n</p>\n<pre><code>var addon = require(&apos;./build/Release/addon&apos;);\n\nconsole.log( &apos;This should be eight:&apos;, addon.add(3,5) );</code></pre>\n&quot;,
              &quot;type&quot;: &quot;module&quot;,
              &quot;displayName&quot;: &quot;Function arguments&quot;
            },
            {
              &quot;textRaw&quot;: &quot;Callbacks&quot;,
              &quot;name&quot;: &quot;callbacks&quot;,
              &quot;desc&quot;: &quot;<!--\nYou can pass JavaScript functions to a C++ function and execute them from\nthere. Here's `addon.cc`:\n-->\n\n<p>JavaScript &#x306E;&#x95A2;&#x6570;&#x3092; C++ &#x306E;&#x95A2;&#x6570;&#x306B;&#x6E21;&#x3057;&#x3066;&#x305D;&#x3053;&#x304B;&#x3089;&#x547C;&#x3073;&#x51FA;&#x3059;&#x3053;&#x3068;&#x304C;&#x3067;&#x304D;&#x307E;&#x3059;&#x3002;\n&#x3053;&#x308C;&#x306F; <code>addon.cc</code> &#x3067;&#x3059;:\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#include &lt;node.h&gt;\n\nusing namespace v8;\n\nHandle&lt;Value&gt; RunCallback(const Arguments&amp; args) {\n  HandleScope scope;\n\n  Local&lt;Function&gt; cb = Local&lt;Function&gt;::Cast(args[0]);\n  const unsigned argc = 1;\n  Local&lt;Value&gt; argv[argc] = { Local&lt;Value&gt;::New(String::New(&quot;hello world&quot;)) };\n  cb-&gt;Call(Context::GetCurrent()-&gt;Global(), argc, argv);\n\n  return scope.Close(Undefined());\n}\n\nvoid Init(Handle&lt;Object&gt; exports, Handle&lt;Object&gt; module) {\n  module-&gt;Set(String::NewSymbol(&quot;exports&quot;),\n      FunctionTemplate::New(RunCallback)-&gt;GetFunction());\n}\n\nNODE_MODULE(addon, Init)</code></pre>\n<!--\nNote that this example uses a two-argument form of `Init()` that receives\nthe full `module` object as the second argument. This allows the addon\nto completely overwrite `exports` with a single function instead of\nadding the function as a property of `exports`.\n-->\n\n<p>&#x3053;&#x306E;&#x4F8B;&#x306F;&#x4E8C;&#x3064;&#x306E;&#x5F15;&#x6570;&#x3092;&#x53D6;&#x308B;&#x5F62;&#x5F0F;&#x306E; <code>Init()</code> &#x3092;&#x4F7F;&#x7528;&#x3057;&#x3066;&#x3001;&#x7B2C;2&#x5F15;&#x6570;&#x3067;&#x5B8C;&#x5168;&#x306A; <code>module</code>\n&#x30AA;&#x30D6;&#x30B8;&#x30A7;&#x30AF;&#x30C8;&#x3092;&#x53D7;&#x3051;&#x53D6;&#x3063;&#x3066;&#x3044;&#x308B;&#x3053;&#x3068;&#x306B;&#x6CE8;&#x610F;&#x3057;&#x3066;&#x304F;&#x3060;&#x3055;&#x3044;&#x3002;\n&#x3053;&#x308C;&#x306F;&#x3001;<code>exports</code> &#x306E;&#x30D7;&#x30ED;&#x30D1;&#x30C6;&#x30A3;&#x3068;&#x3057;&#x3066;&#x95A2;&#x6570;&#x3092;&#x52A0;&#x3048;&#x308B;&#x4EE3;&#x308F;&#x308A;&#x306B;&#x3001;&#x30A2;&#x30C9;&#x30AA;&#x30F3;&#x304C;\n&#x4E00;&#x3064;&#x306E;&#x95A2;&#x6570;&#x3067; <code>exports</code> &#x3092;&#x5B8C;&#x5168;&#x306B;&#x4E0A;&#x66F8;&#x304D;&#x3059;&#x308B;&#x3053;&#x3068;&#x3092;&#x53EF;&#x80FD;&#x306B;&#x3057;&#x307E;&#x3059;&#x3002;\n\n</p>\n<!--\nTo test it run the following JavaScript snippet:\n-->\n\n<p>&#x4EE5;&#x4E0B;&#x306E; JavaScript &#x30B3;&#x30FC;&#x30C9;&#x7247;&#x3067;&#x30C6;&#x30B9;&#x30C8;&#x3059;&#x308B;&#x3053;&#x3068;&#x304C;&#x3067;&#x304D;&#x307E;&#x3059;&#x3002;\n\n</p>\n<pre><code>var addon = require(&apos;./build/Release/addon&apos;);\n\naddon(function(msg){\n  console.log(msg); // &apos;hello world&apos;\n});</code></pre>\n&quot;,
              &quot;type&quot;: &quot;module&quot;,
              &quot;displayName&quot;: &quot;Callbacks&quot;
            },
            {
              &quot;textRaw&quot;: &quot;Object factory&quot;,
              &quot;name&quot;: &quot;object_factory&quot;,
              &quot;desc&quot;: &quot;<!--\nYou can create and return new objects from within a C++ function with this\n`addon.cc` pattern, which returns an object with property `msg` that echoes\nthe string passed to `createObject()`:\n-->\n\n<p>C++ &#x95A2;&#x6570;&#x306E;&#x4E2D;&#x304B;&#x3089;&#x65B0;&#x3057;&#x3044;&#x30AA;&#x30D6;&#x30B8;&#x30A7;&#x30AF;&#x30C8;&#x3092;&#x4F5C;&#x6210;&#x3057;&#x3066;&#x8FD4;&#x3059;&#x3053;&#x3068;&#x304C;&#x3067;&#x304D;&#x307E;&#x3059;&#x3002;\n&#x4EE5;&#x4E0B;&#x306E; <code>addon.cc</code> &#x306E;&#x30D1;&#x30BF;&#x30FC;&#x30F3;&#x3067;&#x306F;&#x3001;<code>createObject()</code> &#x306B;&#x6E21;&#x3055;&#x308C;&#x305F;&#x6587;&#x5B57;&#x5217;&#x3092;\n&#x53CD;&#x6620;&#x3059;&#x308B; <code>msg</code> &#x30D7;&#x30ED;&#x30D1;&#x30C6;&#x30A3;&#x3092;&#x6301;&#x3063;&#x305F;&#x30AA;&#x30D6;&#x30B8;&#x30A7;&#x30AF;&#x30C8;&#x3092;&#x8FD4;&#x3057;&#x307E;&#x3059;&#x3002;\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#include &lt;node.h&gt;\n\nusing namespace v8;\n\nHandle&lt;Value&gt; CreateObject(const Arguments&amp; args) {\n  HandleScope scope;\n\n  Local&lt;Object&gt; obj = Object::New();\n  obj-&gt;Set(String::NewSymbol(&quot;msg&quot;), args[0]-&gt;ToString());\n\n  return scope.Close(obj);\n}\n\nvoid Init(Handle&lt;Object&gt; exports, Handle&lt;Object&gt; module) {\n  module-&gt;Set(String::NewSymbol(&quot;exports&quot;),\n      FunctionTemplate::New(CreateObject)-&gt;GetFunction());\n}\n\nNODE_MODULE(addon, Init)</code></pre>\n<!--\nTo test it in JavaScript:\n-->\n\n<p>&#x30C6;&#x30B9;&#x30C8;&#x7528;&#x306E; JavaScript:\n\n</p>\n<pre><code>var addon = require(&apos;./build/Release/addon&apos;);\n\nvar obj1 = addon(&apos;hello&apos;);\nvar obj2 = addon(&apos;world&apos;);\nconsole.log(obj1.msg+&apos; &apos;+obj2.msg); // &apos;hello world&apos;</code></pre>\n&quot;,
              &quot;type&quot;: &quot;module&quot;,
              &quot;displayName&quot;: &quot;Object factory&quot;
            },
            {
              &quot;textRaw&quot;: &quot;Function factory&quot;,
              &quot;name&quot;: &quot;function_factory&quot;,
              &quot;desc&quot;: &quot;<!--\nThis pattern illustrates how to create and return a JavaScript function that\nwraps a C++ function:\n-->\n\n<p>&#x3053;&#x306E;&#x30D1;&#x30BF;&#x30FC;&#x30F3;&#x306F; C++ &#x95A2;&#x6570;&#x3092;&#x30E9;&#x30C3;&#x30D7;&#x3057;&#x305F; JavaScript &#x95A2;&#x6570;&#x3092;&#x4F5C;&#x6210;&#x3057;&#x3066;&#x8FD4;&#x3059;&#x65B9;&#x6CD5;&#x3092;\n&#x793A;&#x3057;&#x307E;&#x3059;&#x3002;\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#include &lt;node.h&gt;\n\nusing namespace v8;\n\nHandle&lt;Value&gt; MyFunction(const Arguments&amp; args) {\n  HandleScope scope;\n  return scope.Close(String::New(&quot;hello world&quot;));\n}\n\nHandle&lt;Value&gt; CreateFunction(const Arguments&amp; args) {\n  HandleScope scope;\n\n  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(MyFunction);\n  Local&lt;Function&gt; fn = tpl-&gt;GetFunction();\n  fn-&gt;SetName(String::NewSymbol(&quot;theFunction&quot;)); // omit this to make it anonymous\n\n  return scope.Close(fn);\n}\n\nvoid Init(Handle&lt;Object&gt; exports, Handle&lt;Object&gt; module) {\n  module-&gt;Set(String::NewSymbol(&quot;exports&quot;),\n      FunctionTemplate::New(CreateFunction)-&gt;GetFunction());\n}\n\nNODE_MODULE(addon, Init)</code></pre>\n<!--\nTo test:\n-->\n\n<p>&#x30C6;&#x30B9;&#x30C8;:\n\n</p>\n<pre><code>var addon = require(&apos;./build/Release/addon&apos;);\n\nvar fn = addon();\nconsole.log(fn()); // &apos;hello world&apos;</code></pre>\n&quot;,
              &quot;type&quot;: &quot;module&quot;,
              &quot;displayName&quot;: &quot;Function factory&quot;
            },
            {
              &quot;textRaw&quot;: &quot;Wrapping C++ objects&quot;,
              &quot;name&quot;: &quot;wrapping_c++_objects&quot;,
              &quot;desc&quot;: &quot;<!--\nHere we will create a wrapper for a C++ object/class `MyObject` that can be\ninstantiated in JavaScript through the `new` operator. First prepare the main\nmodule `addon.cc`:\n-->\n\n<p>&#x3053;&#x3053;&#x3067;&#x306F;&#x3001;\nC++ &#x30AA;&#x30D6;&#x30B8;&#x30A7;&#x30AF;&#x30C8;&#xFF0F;&#x30AF;&#x30E9;&#x30B9;&#x3092;&#x30E9;&#x30C3;&#x30D7;&#x3057;&#x3001;JavaScript &#x304B;&#x3089; new &#x6F14;&#x7B97;&#x5B50;&#x3092;&#x4F7F;&#x3063;&#x3066;\n&#x30A4;&#x30F3;&#x30B9;&#x30BF;&#x30F3;&#x30B9;&#x5316;&#x3067;&#x304D;&#x308B; <code>MyObject</code> &#x3092;&#x4F5C;&#x6210;&#x3057;&#x307E;&#x3059;&#x3002;\n&#x6700;&#x521D;&#x306B;&#x30E1;&#x30A4;&#x30F3;&#x30E2;&#x30B8;&#x30E5;&#x30FC;&#x30EB; <code>addon.cc</code> &#x3092;&#x6E96;&#x5099;&#x3057;&#x307E;&#x3059;:\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#include &lt;node.h&gt;\n#include &quot;myobject.h&quot;\n\nusing namespace v8;\n\nvoid InitAll(Handle&lt;Object&gt; exports) {\n  MyObject::Init(exports);\n}\n\nNODE_MODULE(addon, InitAll)</code></pre>\n<!--\nThen in `myobject.h` make your wrapper inherit from `node::ObjectWrap`:\n-->\n\n<p>&#x6B21;&#x306B;&#x3001;<code>node::ObjectWrap</code> &#x3092;&#x7D99;&#x627F;&#x3057;&#x305F;&#x30E9;&#x30C3;&#x30D1;&#x30FC;&#x3092; <code>myobject.h</code> &#x306B;&#x4F5C;&#x6210;&#x3057;&#x307E;&#x3059;&#x3002;\n\n</p>\n<pre><code>#ifndef MYOBJECT_H\n#define MYOBJECT_H\n\n#include &lt;node.h&gt;\n\nclass MyObject : public node::ObjectWrap {\n public:\n  static void Init(v8::Handle&lt;v8::Object&gt; exports);\n\n private:\n  explicit MyObject(double value = 0);\n  ~MyObject();\n\n  static v8::Handle&lt;v8::Value&gt; New(const v8::Arguments&amp; args);\n  static v8::Handle&lt;v8::Value&gt; PlusOne(const v8::Arguments&amp; args);\n  static v8::Persistent&lt;v8::Function&gt; constructor;\n  double value_;\n};\n\n#endif</code></pre>\n<!--\nAnd in `myobject.cc` implement the various methods that you want to expose.\nHere we expose the method `plusOne` by adding it to the constructor's\nprototype:\n-->\n\n<p>&#x516C;&#x958B;&#x3057;&#x305F;&#x3044;&#x69D8;&#x3005;&#x306A;&#x30E1;&#x30BD;&#x30C3;&#x30C9;&#x3092; <code>myobject.cc</code> &#x306B;&#x5B9F;&#x88C5;&#x3057;&#x307E;&#x3059;&#x3002;\n&#x3053;&#x3053;&#x3067;&#x306F;&#x3001;&#x30B3;&#x30F3;&#x30B9;&#x30C8;&#x30E9;&#x30AF;&#x30BF;&#x306B;&#x6E21;&#x3055;&#x308C;&#x305F;&#x5024;&#x306B;&#x52A0;&#x7B97;&#x3059;&#x308B; <code>plusOne</code> &#x3092;&#x516C;&#x958B;&#x3057;&#x3066;&#x3044;&#x307E;&#x3059;:\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#include &lt;node.h&gt;\n#include &quot;myobject.h&quot;\n\nusing namespace v8;\n\nPersistent&lt;Function&gt; MyObject::constructor;\n\nMyObject::MyObject(double value) : value_(value) {\n}\n\nMyObject::~MyObject() {\n}\n\nvoid MyObject::Init(Handle&lt;Object&gt; exports) {\n  // Prepare constructor template\n  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(New);\n  tpl-&gt;SetClassName(String::NewSymbol(&quot;MyObject&quot;));\n  tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);\n  // Prototype\n  tpl-&gt;PrototypeTemplate()-&gt;Set(String::NewSymbol(&quot;plusOne&quot;),\n      FunctionTemplate::New(PlusOne)-&gt;GetFunction());\n  constructor = Persistent&lt;Function&gt;::New(tpl-&gt;GetFunction());\n  exports-&gt;Set(String::NewSymbol(&quot;MyObject&quot;), constructor);\n}\n\nHandle&lt;Value&gt; MyObject::New(const Arguments&amp; args) {\n  HandleScope scope;\n\n  if (args.IsConstructCall()) {\n    // Invoked as constructor: `new MyObject(...)`\n    double value = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue();\n    MyObject* obj = new MyObject(value);\n    obj-&gt;Wrap(args.This());\n    return args.This();\n  } else {\n    // Invoked as plain function `MyObject(...)`, turn into construct call.\n    const int argc = 1;\n    Local&lt;Value&gt; argv[argc] = { args[0] };\n    return scope.Close(constructor-&gt;NewInstance(argc, argv));\n  }\n}\n\nHandle&lt;Value&gt; MyObject::PlusOne(const Arguments&amp; args) {\n  HandleScope scope;\n\n  MyObject* obj = ObjectWrap::Unwrap&lt;MyObject&gt;(args.This());\n  obj-&gt;value_ += 1;\n\n  return scope.Close(Number::New(obj-&gt;value_));\n}</code></pre>\n<!--\nTest it with:\n-->\n\n<p>&#x3053;&#x308C;&#x3067;&#x30C6;&#x30B9;&#x30C8;&#x3057;&#x307E;&#x3059;:\n\n</p>\n<pre><code>var addon = require(&apos;./build/Release/addon&apos;);\n\nvar obj = new addon.MyObject(10);\nconsole.log( obj.plusOne() ); // 11\nconsole.log( obj.plusOne() ); // 12\nconsole.log( obj.plusOne() ); // 13</code></pre>\n&quot;,
              &quot;type&quot;: &quot;module&quot;,
              &quot;displayName&quot;: &quot;Wrapping C++ objects&quot;
            },
            {
              &quot;textRaw&quot;: &quot;Factory of wrapped objects&quot;,
              &quot;name&quot;: &quot;factory_of_wrapped_objects&quot;,
              &quot;desc&quot;: &quot;<!--\nThis is useful when you want to be able to create native objects without\nexplicitly instantiating them with the `new` operator in JavaScript, e.g.\n-->\n\n<p>JavaScript &#x306E; <code>new</code> &#x6F14;&#x7B97;&#x5B50;&#x3067;&#x660E;&#x793A;&#x7684;&#x306B;&#x30A4;&#x30F3;&#x30B9;&#x30BF;&#x30F3;&#x30B9;&#x5316;&#x3059;&#x308B;&#x3053;&#x3068;&#x306A;&#x304F;&#x3001;\n&#x30CD;&#x30A4;&#x30C6;&#x30A3;&#x30D6;&#x30AA;&#x30D6;&#x30B8;&#x30A7;&#x30AF;&#x30C8;&#x3092;&#x4F5C;&#x6210;&#x3067;&#x304D;&#x308B;&#x3088;&#x3046;&#x306B;&#x3057;&#x305F;&#x3044;&#x5834;&#x5408;&#x306B;&#x4FBF;&#x5229;&#x3067;&#x3059;&#x3002;&#x4F8B;:\n\n</p>\n<pre><code>var obj = addon.createObject();\n// instead of:\n// var obj = new addon.Object();</code></pre>\n<!--\nLet's register our `createObject` method in `addon.cc`:\n-->\n\n<p>createObject<code> &#x3092; </code>addon.cc` &#x306B;&#x767B;&#x9332;&#x3057;&#x307E;&#x3057;&#x3087;&#x3046;:\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#include &lt;node.h&gt;\n#include &quot;myobject.h&quot;\n\nusing namespace v8;\n\nHandle&lt;Value&gt; CreateObject(const Arguments&amp; args) {\n  HandleScope scope;\n  return scope.Close(MyObject::NewInstance(args));\n}\n\nvoid InitAll(Handle&lt;Object&gt; exports, Handle&lt;Object&gt; module) {\n  MyObject::Init();\n\n  module-&gt;Set(String::NewSymbol(&quot;exports&quot;),\n      FunctionTemplate::New(CreateObject)-&gt;GetFunction());\n}\n\nNODE_MODULE(addon, InitAll)</code></pre>\n<!--\nIn `myobject.h` we now introduce the static method `NewInstance` that takes\ncare of instantiating the object (i.e. it does the job of `new` in JavaScript):\n-->\n\n<p><code>myobject.h</code> &#x306B;&#x30AA;&#x30D6;&#x30B8;&#x30A7;&#x30AF;&#x30C8;&#x3092;&#x751F;&#x6210;&#x3059;&#x308B; static &#x30E1;&#x30BD;&#x30C3;&#x30C9; <code>NewInstance</code> &#x3092;\n&#x5C0E;&#x5165;&#x3057;&#x307E;&#x3057;&#x3087;&#x3046; (&#x3059;&#x306A;&#x308F;&#x3061;&#xFF0C;&#x305D;&#x308C;&#x304C; JavaScript &#x5185;&#x306E; <code>new</code> &#x306E;&#x50CD;&#x304D;&#x3092;&#x3057;&#x307E;&#x3059;)&#x3002;\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#ifndef MYOBJECT_H\n#define MYOBJECT_H\n\n#include &lt;node.h&gt;\n\nclass MyObject : public node::ObjectWrap {\n public:\n  static void Init();\n  static v8::Handle&lt;v8::Value&gt; NewInstance(const v8::Arguments&amp; args);\n\n private:\n  explicit MyObject(double value = 0);\n  ~MyObject();\n\n  static v8::Handle&lt;v8::Value&gt; New(const v8::Arguments&amp; args);\n  static v8::Handle&lt;v8::Value&gt; PlusOne(const v8::Arguments&amp; args);\n  static v8::Persistent&lt;v8::Function&gt; constructor;\n  double value_;\n};\n\n#endif</code></pre>\n<!--\nThe implementation is similar to the above in `myobject.cc`:\n-->\n\n<p>&#x5B9F;&#x88C5;&#x306F;&#x524D;&#x8FF0;&#x306E; <code>myobject.cc</code> &#x3068;&#x540C;&#x69D8;&#x3067;&#x3059;:\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#include &lt;node.h&gt;\n#include &quot;myobject.h&quot;\n\nusing namespace v8;\n\nPersistent&lt;Function&gt; MyObject::constructor;\n\nMyObject::MyObject(double value) : value_(value) {\n}\n\nMyObject::~MyObject() {\n}\n\nvoid MyObject::Init() {\n  // Prepare constructor template\n  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(New);\n  tpl-&gt;SetClassName(String::NewSymbol(&quot;MyObject&quot;));\n  tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);\n  // Prototype\n  tpl-&gt;PrototypeTemplate()-&gt;Set(String::NewSymbol(&quot;plusOne&quot;),\n      FunctionTemplate::New(PlusOne)-&gt;GetFunction());\n  constructor = Persistent&lt;Function&gt;::New(tpl-&gt;GetFunction());\n}\n\nHandle&lt;Value&gt; MyObject::New(const Arguments&amp; args) {\n  HandleScope scope;\n\n  if (args.IsConstructCall()) {\n    // Invoked as constructor: `new MyObject(...)`\n    double value = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue();\n    MyObject* obj = new MyObject(value);\n    obj-&gt;Wrap(args.This());\n    return args.This();\n  } else {\n    // Invoked as plain function `MyObject(...)`, turn into construct call.\n    const int argc = 1;\n    Local&lt;Value&gt; argv[argc] = { args[0] };\n    return scope.Close(constructor-&gt;NewInstance(argc, argv));\n  }\n}\n\nHandle&lt;Value&gt; MyObject::NewInstance(const Arguments&amp; args) {\n  HandleScope scope;\n\n  const unsigned argc = 1;\n  Handle&lt;Value&gt; argv[argc] = { args[0] };\n  Local&lt;Object&gt; instance = constructor-&gt;NewInstance(argc, argv);\n\n  return scope.Close(instance);\n}\n\nHandle&lt;Value&gt; MyObject::PlusOne(const Arguments&amp; args) {\n  HandleScope scope;\n\n  MyObject* obj = ObjectWrap::Unwrap&lt;MyObject&gt;(args.This());\n  obj-&gt;value_ += 1;\n\n  return scope.Close(Number::New(obj-&gt;value_));\n}</code></pre>\n<!--\nTest it with:\n-->\n\n<p>&#x3053;&#x308C;&#x3067;&#x30C6;&#x30B9;&#x30C8;&#x3057;&#x307E;&#x3059;:\n\n</p>\n<pre><code>var createObject = require(&apos;./build/Release/addon&apos;);\n\nvar obj = createObject(10);\nconsole.log( obj.plusOne() ); // 11\nconsole.log( obj.plusOne() ); // 12\nconsole.log( obj.plusOne() ); // 13\n\nvar obj2 = createObject(20);\nconsole.log( obj2.plusOne() ); // 21\nconsole.log( obj2.plusOne() ); // 22\nconsole.log( obj2.plusOne() ); // 23</code></pre>\n&quot;,
              &quot;type&quot;: &quot;module&quot;,
              &quot;displayName&quot;: &quot;Factory of wrapped objects&quot;
            },
            {
              &quot;textRaw&quot;: &quot;Passing wrapped objects around&quot;,
              &quot;name&quot;: &quot;passing_wrapped_objects_around&quot;,
              &quot;desc&quot;: &quot;<!--\nIn addition to wrapping and returning C++ objects, you can pass them around\nby unwrapping them with Node's `node::ObjectWrap::Unwrap` helper function.\nIn the following `addon.cc` we introduce a function `add()` that can take on two\n`MyObject` objects:\n-->\n\n<p>C++ &#x30AA;&#x30D6;&#x30B8;&#x30A7;&#x30AF;&#x30C8;&#x3092;&#x30E9;&#x30C3;&#x30D7;&#x3057;&#x3066;&#x8FD4;&#x3059;&#x3053;&#x3068;&#x306B;&#x52A0;&#x3048;&#x3066;&#x3001;Node &#x304C;&#x63D0;&#x4F9B;&#x3059;&#x308B;&#x30D8;&#x30EB;&#x30D1;&#x95A2;&#x6570;\n<code>node::ObjectWrap::Unwrap</code> &#x3092;&#x4F7F;&#x7528;&#x3057;&#x3066;&#x30A2;&#x30F3;&#x30E9;&#x30C3;&#x30D7;&#x3059;&#x308B;&#x3053;&#x3068;&#x3082;&#x3067;&#x304D;&#x307E;&#x3059;&#x3002;\n&#x4EE5;&#x4E0B;&#x306E; <code>addon.cc</code> &#x3067;&#x306F;&#x3001;&#x4E8C;&#x3064;&#x306E; <code>MyObject</code> &#x30AA;&#x30D6;&#x30B8;&#x30A7;&#x30AF;&#x30C8;&#x3092;&#x53D7;&#x3051;&#x53D6;&#x308B; <code>add()</code>\n&#x95A2;&#x6570;&#x3092;&#x5C0E;&#x5165;&#x3057;&#x307E;&#x3059;:\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#include &lt;node.h&gt;\n#include &quot;myobject.h&quot;\n\nusing namespace v8;\n\nHandle&lt;Value&gt; CreateObject(const Arguments&amp; args) {\n  HandleScope scope;\n  return scope.Close(MyObject::NewInstance(args));\n}\n\nHandle&lt;Value&gt; Add(const Arguments&amp; args) {\n  HandleScope scope;\n\n  MyObject* obj1 = node::ObjectWrap::Unwrap&lt;MyObject&gt;(\n      args[0]-&gt;ToObject());\n  MyObject* obj2 = node::ObjectWrap::Unwrap&lt;MyObject&gt;(\n      args[1]-&gt;ToObject());\n\n  double sum = obj1-&gt;Value() + obj2-&gt;Value();\n  return scope.Close(Number::New(sum));\n}\n\nvoid InitAll(Handle&lt;Object&gt; exports) {\n  MyObject::Init();\n\n  exports-&gt;Set(String::NewSymbol(&quot;createObject&quot;),\n      FunctionTemplate::New(CreateObject)-&gt;GetFunction());\n\n  exports-&gt;Set(String::NewSymbol(&quot;add&quot;),\n      FunctionTemplate::New(Add)-&gt;GetFunction());\n}\n\nNODE_MODULE(addon, InitAll)</code></pre>\n<!--\nTo make things interesting we introduce a public method in `myobject.h` so we\ncan probe private values after unwrapping the object:\n-->\n\n<p>&#x3088;&#x308A;&#x304A;&#x3082;&#x3057;&#x308D;&#x304F;&#x3059;&#x308B;&#x305F;&#x3081;&#x306B;&#x3001;<code>myobject.h</code> &#x306B;&#x30D1;&#x30D6;&#x30EA;&#x30C3;&#x30AF;&#x30E1;&#x30BD;&#x30C3;&#x30C9;&#x3092;&#x5C0E;&#x5165;&#x3057;&#x307E;&#x3057;&#x3087;&#x3046;&#x3002;\n&#x3057;&#x305F;&#x304C;&#x3063;&#x3066;&#x3001;&#x30A2;&#x30F3;&#x30E9;&#x30C3;&#x30D7;&#x3055;&#x308C;&#x305F;&#x30AA;&#x30D6;&#x30B8;&#x30A7;&#x30AF;&#x30C8;&#x306E;&#x30D7;&#x30E9;&#x30A4;&#x30D9;&#x30FC;&#x30C8;&#x5909;&#x6570;&#x3092;&#x8ABF;&#x3079;&#x308B;&#x3053;&#x3068;&#x304C;\n&#x3067;&#x304D;&#x307E;&#x3059;&#x3002;\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#ifndef MYOBJECT_H\n#define MYOBJECT_H\n\n#include &lt;node.h&gt;\n\nclass MyObject : public node::ObjectWrap {\n public:\n  static void Init();\n  static v8::Handle&lt;v8::Value&gt; NewInstance(const v8::Arguments&amp; args);\n  double Value() const { return value_; }\n\n private:\n  explicit MyObject(double value = 0);\n  ~MyObject();\n\n  static v8::Handle&lt;v8::Value&gt; New(const v8::Arguments&amp; args);\n  static v8::Persistent&lt;v8::Function&gt; constructor;\n  double value_;\n};\n\n#endif</code></pre>\n<!--\nThe implementation of `myobject.cc` is similar as before:\n-->\n\n<p><code>myobject.cc</code> &#x306E;&#x5B9F;&#x88C5;&#x306F;&#x3053;&#x308C;&#x307E;&#x3067;&#x3068;&#x540C;&#x69D8;&#x3067;&#x3059;:\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#include &lt;node.h&gt;\n#include &quot;myobject.h&quot;\n\nusing namespace v8;\n\nPersistent&lt;Function&gt; MyObject::constructor;\n\nMyObject::MyObject(double value) : value_(value) {\n}\n\nMyObject::~MyObject() {\n}\n\nvoid MyObject::Init() {\n  // Prepare constructor template\n  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(New);\n  tpl-&gt;SetClassName(String::NewSymbol(&quot;MyObject&quot;));\n  tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);\n  constructor = Persistent&lt;Function&gt;::New(tpl-&gt;GetFunction());\n}\n\nHandle&lt;Value&gt; MyObject::New(const Arguments&amp; args) {\n  HandleScope scope;\n\n  if (args.IsConstructCall()) {\n    // Invoked as constructor: `new MyObject(...)`\n    double value = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue();\n    MyObject* obj = new MyObject(value);\n    obj-&gt;Wrap(args.This());\n    return args.This();\n  } else {\n    // Invoked as plain function `MyObject(...)`, turn into construct call.\n    const int argc = 1;\n    Local&lt;Value&gt; argv[argc] = { args[0] };\n    return scope.Close(constructor-&gt;NewInstance(argc, argv));\n  }\n}\n\nHandle&lt;Value&gt; MyObject::NewInstance(const Arguments&amp; args) {\n  HandleScope scope;\n\n  const unsigned argc = 1;\n  Handle&lt;Value&gt; argv[argc] = { args[0] };\n  Local&lt;Object&gt; instance = constructor-&gt;NewInstance(argc, argv);\n\n  return scope.Close(instance);\n}</code></pre>\n<!--\nTest it with:\n-->\n\n<p>&#x3053;&#x308C;&#x3067;&#x30C6;&#x30B9;&#x30C8;&#x3057;&#x307E;&#x3059;:\n\n</p>\n<pre><code>var addon = require(&apos;./build/Release/addon&apos;);\n\nvar obj1 = addon.createObject(10);\nvar obj2 = addon.createObject(20);\nvar result = addon.add(obj1, obj2);\n\nconsole.log(result); // 30</code></pre>\n&quot;,
              &quot;type&quot;: &quot;module&quot;,
              &quot;displayName&quot;: &quot;Passing wrapped objects around&quot;
            }
          ],
          &quot;type&quot;: &quot;module&quot;,
          &quot;displayName&quot;: &quot;Addon patterns&quot;
        }
      ],
      &quot;type&quot;: &quot;module&quot;,
      &quot;displayName&quot;: &quot;Addons&quot;
    }
  ]
}

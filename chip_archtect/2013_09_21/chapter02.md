# 第2章 Opteronの浮動小数点ユニット

- 2.1 浮動小数点のリネームレジスタファイル
- 2.2 浮動小数点リネームステージ1 : x87のスタックから絶対FPレジスタファイルへのマッピング
- 2.3 浮動小数点リネームステージ2 : 通常のレジスタリネーミング
- 2.4 浮動小数点命令スケジューラ
- 2.5 5ポート読み込みと5ポート書き込みの浮動小数点リネームレジスタファイル
- 2.6 浮動小数点演算ユニット
- 2.7 変換と分類ユニット
- 2.8 x87状態処理 : FCOMI/FCMOV と FCOM/FSTSWペア

![Opteron's Floating Point Processing Unit's](Opteron_FloatPnt_Core.jpg)

## 2.1 浮動小数点のリネームレジスタファイル

Opteronの浮動小数点リネームレジスタファイルは、88から120エントリに増加している。
このリネームレジスタファイルは言葉通りの意味のレジスタファイルである。
単一のエンティティを持っており、すべてのアーキテクチャ的な(非投機的な)値と、命令セットにより定義されたレジスタの投機的な値を保持している。

Opteronは再度72個の投機的な命令を格納することができる。
AthlonXPコアにより、投機的な命令のサポートは72命令から56命令に削減された。
AthlonXPではSSEのための128個のXMMレジスタファイルも含まれているが、88個のリネームレジスタファイルの数が増えることはなかった。

128bitのXMMレジスタはリネームレジスタファイル内の2つのエントリを使用する。
したがってOpteronは16個のXMMアーキテクチャ(リタイアした)レジスタを保持するために32エントリを利用する。
これにより、88+32エントリで120エントリとなる。

120エントリのうち40エントリはアーキテクチャの(非投機的な)レジスタの状態を保持するために使用される。
32エントリは16個のXMMレジスタ用である。残りの8つは8つのx87/MMXレジスタ用である。

さらに8つのレジスタエントリを、マイクロコードのスクラッチレジスタとして使用する。
これは時々マイクロアーキテクチャレジスタと呼ばれる。
これらのレジスタは命令セットとしては定義されておらず、プログラマからは直接見ることはできない。
これらのレジスタはマイクロコードが、三角関数や対数関数などの複雑な計算を行うために利用される。

48(40+8)エントリにより定義されるプロセッサのアーキテクチャ的な状態は、「アーキテクチャタグアレイ(Architectural Tag Array)」
として定義されている。
このエントリは、48個のアーキテクチャ的なレジスタエントリの最新の「投機的な」値を保持しており、「フューチャーファイルタグアレイ
(Future File Tag Array)」と呼ばれる。

プロセッサの投機的な状態は、分岐予測や例外の発生により解放されることがある。
これはフューチャーファイルの48個エントリをアーキテクチャタグアレイで上書きすることで実現される。

リネームレジスタファイルは90bit幅である。
浮動小数点のデータは全体で90bitまで拡張される(68bitと仮数部、18ビットの指数部、1ビットの符号ビット、3ビットの分類ビットである)。
3つの分類ビット委は、浮動小数点数の情報が付加される。
この分類ビットは、非浮動小数点数(整数)など、リネームレジスタファイルに書き込む際に拡張する必要のない値を識別するときなどに利用される。

|    | The 120 registers                  |   |    | The 90 bit registers              |   |   | Definition of the 3bit Class Code  |
|----|------------------------------------|---|----|-----------------------------------|---|---|------------------------------------|
|    | non speculative registers:         |   |    | subdivision of the 90 bits for FP |   | 0 | Zero                               |
| 8  | FP/MMX registers(arch.)            |   | 68 | Mantisse bits                     |   | 1 | Inifinity                          |
| 32 | SSE/SSE2 registers(arch.)          |   | 18 | Exponent bits                     |   | 2 | Quit NAN (Not A Number)            |
| 8  | Micro Code Scratch Registers(arch) |   | 1  | Sign bit                          |   | 3 | Signaling NAN (Not A Number)       |
|    | speculative registers              |   | 3  | Class Code bits                   |   | 4 | Denormal (very small FP number)    |
| 8  | FP/MMX registers(latest)           |   |    |                                   |   | 5 | MMX/MMX (non FP contents)          |
| 32 | SSE/SSE2 registers(lates)          |   |    |                                   |   | 6 | Normal (FP number, not very small) |
| 8  | Micro Code Scratch reg.(latest)    |   |    |                                   |   | 7 | Unsupported                        |
| 24 | Renaming speculative               |   |    |                                   |   |   |                                    |

![Opteron's Floating Point Core](Opteron_FloatPnt_Core_Ill.jpg)

<<<<<<< HEAD
# 2.3 浮動小数点リネームステージ2 : 通常のレジスタリネーミング

実際のレジスタリネーミングはこのステージで実行される。
このステージで、書き込み先レジスタが必要な命令は、リネームされたレジスタ割り当てを取得する。
書き込みレジスタは実行中の他のどのような命令とも違っていなければならない。
ドの命令も同一のレジスタに書き込むことはないのである。
フリーリストからは、最大で3つのレジスタエントリを取得することができる。
全体では120個のレジスタが使用可能である。
フリーリストは、最大で72個のフリーエントリを保持することができ、最大で同時に実行中にすることができる命令の数に等しい。

リネーミングしている48エントリは、アーキテクチャ的な(非投機的な)レジスタの値を保持している:8つのx87/MMXレジスタである。
8つのスクラッチレジスタ(マイクロコードでのみアクセス可能)とSSEとSSE２で利用される128bitのXMMレジスタは、それぞれ2エントリ使用する。
これらのレジスタは場所が固定されているわけではないが、120エントリのうちどこかを利用することになる。
これにより、フリーリストが必要になるわけである。
48エントリは、上記に述べたように、48個の「アーキテクチャタグアレイ」によって識別するためのアーキテクチャレジスタによって利用される。
アーキテクチャタグアレイは、120個のリネームレジスタから、各アーキテクチャレジスタが度のエントリにマッピングされているかを示すためのアレイである。

1サイクルあたり最大で3命令をリネーミングすることができる。
データ依存は、「フューチャーファイルタグアレイ」という他の機構を用いて処理される。
このアレイは、投機的なあた値を保持している48個のリネームレジスタへのポインタを保持している。
命令はリネーミングされたレジスタアクセスを行うために、このアレイにアクセスすることによりソースオペランドを取得することができる。
命令はフューチャータグアレイに、リネームされた情報を配置し、これにより後続の命令はその命令の結果が格納される場所を知ることができる。

例: ある命令がアーキテクチャレジスタの3と5を入力オペランドとして利用し、レジスタ3を書き込み先として使用する。
最初にエントリ3と5を読み、レジスタ3とレジスタ5の投機的な値が格納されているリネームレジスタのポインタを取得する。
このリネームレジスタの場所を93と12であるとする。
この命令は入力オペランドの場所を取得したので、フューチャータグアレイのレジスタ番号3の位置に結果が格納されるリネームレジスタのエントリ番号を書き込む。
これを例えば97とする。
後続の命令で、レジスタ防ン号3が必要な命令は、リネームレジスタ97を利用してアクセスすることになる。

例外や分岐予測ミスが発生したときは、フューチャータグアレイの48エントリを、アーキテクチャタグアレイの48エントリで上書きする。
これですべての投機的に実行された命令は破棄される。
アーキテクチャタグアレイのポインタはリタイア処理の論理によって書き込まれる。
リタイア処理は1サイクルあたり3つの値を書き込むことができる。
これらの値はリオーダバッファから供給される。
リオーダバッファはすべての命令が共有している。

浮動小数点命令は、命令が終了したときに例外情報のようないくつかの情報を保持しており、TOSなどが、リオーダバッファに格納する。
この情報には、この命令が変更した書き込み先のレジスタ情報などが含まれている。
リオーダバッファにはアーキテクチャレジスタの番号とリネームレジスタの番号が含まれている。
これらのうち2つが、リタイア処理の際にアーキテクチャタグアレイの更新に利用される。
1つはデータであり、もう一つはアーキテクチャタグアレイのエントリ番号である。

## 2.2 浮動小数点リネームステージ1 : x87のスタックから絶対FPレジスタファイルへのマッピング

レガシーなx87命令の「スタック機能」は、浮動小数点パイプラインのステージ1では機能していない。
x87命令は8つの80ビットのアーキテクチャレジスタに対して、3ビットのTop of Stack(TOS)ポインタ経由でアクセスする。
命令セットは、TOSをソースオペランドにも、書き込みオペランドにも利用する。
2番目の引数は、TOSレジスタからの相対値とするか、メモリオペランドとするかを選択できる。
3ビットのTOSポインタは16bitのx87 FP状態レジスタによって管理されている。

x87 TOSレジスタへの相対アクセスは、演算にもとづくx87レジスタの絶対アドレスに変換される。
TOSレジスタの投機的バージョンは、この変換のために利用されている。
3ビットのポインタは、1サイクルあたり最大で3命令分アップデートすることができる。
命令は投機的に実行されるが、まだこのステージではインオーダでらう。
これらの命令はまだ浮動小数点のアウトオブオーダースケジューラでスケジューリングはされていない。

もし例外や分岐予測ミスが発生すると、投機的なTOSポインタは、否投機的な、リタイアしたTOSポインタから書き戻される。
これはリオーダバッファから書き戻されることになる。
リタイアした値はTOSのに関連する値が、全て例外か、分岐予測ミスの発生前のものであるという前提のもと構成されている。

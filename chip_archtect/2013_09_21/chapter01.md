AMDの64ビットコア詳細アーキテクチャの理解
=========================================

マルチプロセッサ環境において、ワールドクラスの投機アウトオブオーダ64ビットプロセッサを構築するために何が起きているのかを真に知りたい人向け

# 第1章: 整数コア: 整数スーパハイウェイ

- 1.1 整数スーパーハイウェイ
- 1.2 3-wayスーパスカラCISCアーキテクチャ
- 1.3 命令の3種の階層: ダブルディスパッチ操作
- 1.4 128bit SSE(2)命令はDoublesに分解される
- 1.5 128bit SSE(2)命令にDoubleを使うことにより25%のレイテンシペナルティの発生を避けることができる
- 1.6 Doublesはいくつかの整数命令とx87命令を同時に利用する
- 1.7 Doubleは128bitのメモリアクセスを処理できる
- 1.8 スケジューリング前のアドレス加算
- 1.9 レジスタリネーミングとアウトオブオーダ処理
- 1.10 整数レジスタのリネーミング
- 1.11 IFFRF: Integer Future File and Register File
- 1.12 IFFRFの"Future File"セクション
- 1.13 例外および分岐予測ミス: リタイア値で投機実行結果を上書きする
- 1.14 リオーダバッファ
- 1.15 リタイア処理と例外処理
- 1.16 例外処理は、リタイア処理まで常に遅延される
- 1.17 ベクトルパスとダブルディスパッチ命令のリタイア処理
- 1.18 アウトオブオーダ処理: 命令ディスパッチ
- 1.19 スケジューラ / リザベーションステーション
- 1.20 各x86命令はALUとAGU操作を起動することができる
- 1.21 ALU操作のスケジューリング
- 1.22 メモリアクセスのためのAGU操作のスケジューリング
- 1.23 Opteronの整数コアのマイクロアーキテクチャの利点

# 第1章: 整数コア: 整数スーパハイウェイ

## 1.1 整数スーパーハイウェイ

整数コアのダイ写真を見ると、殆どの領域が64bitのデータバスであることが分かる。
データバスは北から南にかけて張られている。
いくつかの領域では、最大で20種類のバスが集積されている。
バスは、整数ユニットで利用される全てのソースオペランドと出力オペランドを転送している。
バスのレイアウトは*ビットインタリーブ*の形式で設計されており、各ビットはビットインデックスでグループ化されている。
全てのバスのビット0は集められ、隣同士に配置されている。
一方で、ビット63はもう片方の領域にまとめられている。
各バイトで分割されているのは、レイアウトからも分かりやすく確認できる。

![Opteron Integer Core](Opteron_Integer_Core.jpg)

## 1.2 3-wayスーパスカラCISCアーキテクチャ

Opteronは3-wayスーパスカラプロセッサである。
このプロセッサは1サイクルあたり3つのx86命令をデコード、実行、リタイアすることができる。
これらの実行される命令は非常に複雑な命令(CISC)であり、複数(2以上)のソースオペランドを持っている。
Pentium 4はサイクルあたり3つのuOpsと呼ばれる操作を実行することができる。
単一のx86命令を実行するためには、複数のuOpsを実行する必要がある。
私達の調査により、Prescottではサイクルあたり最大で4つのuOpsを実行することができることが分かっている。

一般的に、x86命令は F(reg, reg)、F(reg, mem)、F(mem, reg)として表現される。
最初のオペランドは、ソースと出力の両方を取ることができる。
最初の2つの形式は整数命令、MMX、SSE(2)において標準的な形式である。
最後の形式は基本的に整数命令において見られる。
1つのソースオペランドがメモリから読み込まれ、結果は同じ領域に書き戻される。
整数パイプラインは、浮動小数点命令とマルチメディア命令を含む、全ての処理においてロードとストア処理を実行するのに利用される。

![Overview of Opteron's Processor Core](Opteron_MPF_12.jpg)

## 1.3 命令の3種の階層: ダブルディスパッチ操作

オリジナルのAthlon(Athlon 32とも呼ばれている)は命令をDirectPathとVectorPathに分類していた。
最初のクラスの命令は、複雑度の低い命令で、ハードウェアで単一の操作で実行できるような命令である。
より複雑な命令(VectorPath)では複数のマイクロシーケンサが起動され、マイクロコードプログラムが実行される。
命令はマイクロコードROMから読み込まれ、3-wayパイプラインに挿入される。

Opteronは3番目の命令クラスを導入した。
Double Dispatch命令、もしくは単に"Doubles"と呼ばれる。
Doublesはデコーディングパイプラインの最後の段で生成される。
DirectPathもしくはMicroCodeシーケンサにより生成された直後の命令は、2つの独立した命令に分割される。
3-wayパイプラインは、従って1サイクルあたり6つの命令を生成することになる。
これらの命令はPACKステージにより「再パッキング」され、3つの命令に戻される。
この追加されたパイプラインステージは、投機実行のために追加されたものであり、Opteronが2001年にMicro Processor Forumで紹介されたときからのものである。
6つの対照的な形をした"doubling stae"は、上記のダイ写真からもはっきりと確認できる。

## 1.4 128bit SSE(2)命令はDoublesに分解される

Opteronの最適化ガイドでは、全ての命令のどのクラスに分類されるかが記述されている。
ほとんどの128bitのSSE、SSE2命令はDouble Dispatch命令として実装されている。
独立した64bitの命令に分割することのできない命令のみ、VectorPath(マイクロコード)命令として処理される。
これらのSSE2命令で、128bitレジスタの半分しか使わない命令はSingle命令(Direct Path)命令として実装される。

Double Dispatch命令には、性能面においてトレードオフが存在する。
欠点は、128bit SSE2命令のデコード率がサイクルあたり1.5に制限される点である。
しかし一般的には、最大スループットは128bitSSE Single命令においてFPユニットとリタイアのハードウェアにに制限されるため、デコード率により性能の制約になることはない。
より重要なのはサイクルレイテンシが余分に必要な問題であり、Pentium4スタイルの実装により生じるレイテンシの問題を避けることができる。

## 1.5 128bit SSE(2)命令にDoubleを使うことにより25%のレイテンシペナルティの発生を避けることができる

Pentium 4では、SSE2命令は浮動小数点ユニットの後ろのステージで分割される。
浮動小数点ユニットは128ビットのソースデータを、最初のステージで受け入れることができる。
このデータを2つの操作に分割し、2つの結果をつなげて最後に128ビットの1つのデータとする。
この構成により、全体のレイテンシは効率的に1サイクルほど増加する。
例えば、x87のFADDとFMUL命令はそれぞれ5サイクルと7サイクルで実行されるが、128ビットのSSE命令では、それぞれ6サイクルと8サイクル必要である。

Opteronは、Athlon 32と似通っている。
OpteronはFADDとFMUL命令を4サイクルで実行する。
SSE2の命令は同一の4サイクルのレイテンシで実行される。
1サイクルの増加は、25％のレイテンシの増加につながり、重要な性能低下につながるため、
高度にパイプライン化されたFPユニットの動作を考えるならばこの選択は正しい。
そうでないと、パイプライン中に多くのバブルが挿入され、命令効率が低下するからだ。
他の命令の結果を待つ命令は、その命令が終了するのを待たなければならない。
レイテンシは、バンド幅にとって重要な問題なのだ。

次期Pentiumプロセッサ、コードネームPrescottでは、さらに浮動小数乗算帰途、浮動小数点加算器を追加することでこの問題を解消しようとしている。
この追加されたFPユニットはシングルポートだが、128ビットの演算ができるものと予想する。
これによりSSE2のレイテンシは元に戻り、加算と乗算は5サイクルと7サイクルで実行できるようになるだろう。
単一スレッドのプログラムでは性能が改善する可能性がある。
さらに、浮動小数点のバンド幅は、ハイパースレッディングの性能により倍増すると予想される。

## 1.6 Doublesはいくつかの整数命令とx87命令を同時に利用する

Double Dispatch命令はSSEとSSE2命令でのみ使われるわけではない。
Opteronの最適化ガイドのAppendix Cでは、POPやPUSH、いくつかの整数乗算及びLEAVE命令などのクラシックなx86命令もリストアップされている。
Athlon 32では、すべての命令はマイクロコードとして実行されるため、低速であった。
いくつかのx87命令は、現在はDouble命令として処理されている。
例えば、FP命令のうちでソースオペランドの一つが整数であるため、最初に浮動小数点に変換する必要がある命令が該当する。

## 1.7 Doubleは128bitのメモリアクセスを処理できる

SSEとSSE2で利用される128bitメモリアクセスを2つの独立した64ビットアクセスに分割し、整数コアで処理する。
データキャッシュから出力されるロードデータバス上の結果は浮動小数点コアにより取り込まれる。
整数レジスタを32bitから64bitに拡張し、128bitのSSE(2)命令を2つの64bitの結果に分割することは、すべての64bitマイクロアーキテクチャにおいてはエレガントな解決法である。

L1データキャッシュにおいて、128bitのロード、ストアを2つの独立した64bitのロード、ストアとして扱うことには、重大な利点がある。
2つの異なるアドレスからの64bitロードし、2つの移動処理により1つの128bitSSE2レジスタに格納するのは、1つの128bitデータをロードすることと同じくらいの速度である。
Appleは32ビットの浮動小数点データを128bitデータタイプとしてロードすことに対する適切な主張を行っている。
非常に鮮明なARGBカラーイメージデータを使う場合などである(xxx)。
(消費者が使う場合に、)2つの64bit浮動小数点数を1つの128bitのワードに格納するような、実用的な商用アプリケーションは存在しない。
(もしくは、あるいはコンパイラの開発が伴っていないだけなのか...)。
異なる64bitのロードとストアを1サイクルあたりに2つ出せたほうが、コンパイラは関係ない64bitの演算命令を128bitのメモリアクセスの中に挿入することができ、
より最適化を図れるようになる。


## 1.8 スケジューリング前のアドレス加算

一つのx86命令において、ソースオペランドにメモリアクセスが必要な場合は

addres = base + index < scale + displacement + segment

アドレスを計算するために最大で4つの引数が必要になる(ハードコーディングされた2ビットのscale-fieldは無視する)
これにより、典型的なx86命令のフォーマットF(reg, mem)では、少なくとも5つの入力オペランドが必要になることが分かる！
現在、そのパラメータの一つが命令自身によって与えられるパラメータ(displacement)である。
他のパラメータ(セグメント)は「準定数(semi-constant)」であり、セグメント化されていない、フラットなメモリ空間で利用される
現在のコードでは、典型的に0である。

Athlon 32では、3つのAGU(Address Generator Unit)のうち一つが、線形アドレスを計算した後に必要であれば、
セグメントをアドレスに加算する。
これには、データキャッシュアクセスが生じ、ロードレイテンシに余分なキャッシュサイクルが必要になる。
Opteronは、異なる実装を行っている。
displacementとsegmentは実際のアドレス計算が行われる前に加算が実行されるのである。

segmentの値はでコード中はdisplacementと同じく定数と考えることができる。
でコード・ディスパッチの間に加算が行われ、加算結果は、命令bitの残りの領域(命令の新しいdisplacement field)
とともに次のステージに渡される。

segmentの値が変わった場合はいつでも例外が生成される。
例外が発生した場合、命令が生成した結果はキャンセルされ、パイプラインは正しい場所から再スタートされる。

"Decode-Time"アドレス加算器は他のアドレス加算にも同様に使用される。
(64bitモードでは、ほとんどのセグメンテーションが除去される)

例えば、新しい相対アドレスモードにおいて、命令から64bitの命令ポインタ(RIP)と32ビットのdisplacementを
加算するのに使用される。
入力パラメータを可能な限り削減することにより、最終的なデコード時の最大入力パラメータが
分かるようになる。入力パラメータのうち3つはレジスタ値であり、4つ目は定数である。

![Opteron's Segment Adders](Opteron_Segment_Adders_780x1408.jpg)

![Opteron's Integer Core](Opteron_Integer_Core_Ill.jpg)

## 1.9 レジスタリネーミングとアウトオブオーダ処理

Athlon(とOpteron)は、レジスタリネーミングとアウトオブオーダ処理を処理するために賢い処理を追加しており、
25%の整数パイプラインを削減している。
これにより、キャッシュミスによるミススケジューリングを処理するための特殊なハードウェアが不要になり、デザインがよりシンプルで高速になる。

レジスタリネーミングは「負の依存関係」を除去するために使用させる。
この負の依存関係により、1サイクルあたりの命令数(Instruction Per Cycle: IPC)が制限される。
負の依存関係は、利用できるレジスタ数の制限によるものである。
すぐに利用できる結果を保持しているレジスタは、他の命令が利用したいときはすぐに利用できるようにする必要がある。
この値は上書きされ、使用できなくなる。
上書きをする命令は、過去の命令を利用するすべての命令が実行されるのを待つ必要がある。

これにより命令の実行が制限され、IPCが低下する。
x86のようなレジスタ数の少ないアーキテクチャにおいて、この症状は事実である。
以下の例では、レジスタリネーミングがこの問題をどのように解決するかを示している：
Register rCは3番目の命令により上書きされるため、3番目命令は2番目の命令を待つ必要がある。
これが負の依存関係である。
レジスタリネーミングによりアーキテクチャの持つレジスタ数よりも大きな量のレジスタ数を使えるようになる。
ここでrCを再利用する必要はなくなる。
他のレジスタを利用すればよいため、この場合はr7を利用している。
基本的なルールは、「実行中の」すべての命令は異なる書き込みレジスタを保持している、ということである(single assignment)。

## 1.10 整数レジスタのリネーミング

Opteronは16個の64bitアーキテクチャ整数レジスタを持っている。
複雑なx86命令を処理するために、さらに8つの64bitスクラッチレジスタ持っており、マイクロコードルーチンが使用する測地を格納するために利用している。
このスクラッチレジスタはプログラマから見えることはない。
Athlonファミリのプロセッサはレジスタリネーミングをもっとも単純な手法で実現している。
この手法は、どのようにして簡単な方法でレジスタリネーミングを実現するかを明らかに薄るのに、賢明な考えを多く含んでおり、称賛されるべきものである。
これを考え付く人はそうはいないだろう。

これまでに述べたように、実行中の各命令は異なる戻り値レジスタを持っている。
理ネーミングされたレジスタの合計数はすべての「実行中の命令」の合計と「アーキテクチャレジスタ」の合計である。
最大で実行できる命令数は72であり、「リネーミングされたレジスタ」の合計値は96になる。
これらのレジスタを管理するために、2つの異なる構造が使われている。
実行中の命令の結果は72エントリのリオーダバッファ(Re-Order Buffer:ROB)により管理されており、アーキテクチャレジスタは
「整数フューチャーファイルおよびレジスタファイル(Integer Future File and Register File: IFFRF)」により管理されている。

![Re-Order-Buffer Tag definition](reorder_tag_definition.JPG)

この構成により、非常に単純でレイテンシが0サイクルとなるリネーミング処理を実現できる。
各命令は3つのデコードレーンの1つよりディスパッチされ、「リオーダバッファタグ」もしくは「院フライト命令タグ」を取得する。

1. sub-index 0,1,2はどのレーンからディスパッチされた命令化を示している。
2. 0..23の値はディスパッチされた命令の「サイクル」を示している。「サイクルカウンタ」は0から23まででラップされている。
3. wrap bit。2つの命令が異なるwrap bitを持っていたならば、サイクルカウンタは2つのディスパッチの間でラップされる。

## 1.11 IFFRF: Integer Future File and Register File

レジスタファイルは、16個のアーキテクチャレジスタと8つのテンポラリスクラッチレジスタを管理するために利用されている。
レジスタファイルは2つのエントリを持っており、それぞれ16個のアーキテクチャレジスタを管理するために利用される。
2つのエントリのうち1つは、プログラマから見える実際のレジスタとしてみることができる。
子のレジスタは、命令が「リタイア」したときの値を格納している。
命令が完了し、例外及び分岐予測ミスが発生しないことが分かり、その命令よりも前の命令がすべてリタイアしている場合にリタイアされる。
レジスタの値は「非投機的」である。

![40 entry Integer Future File and Register File:IFFRF](iffrf.JPG)

実行中の命令は、その命令がリタイアされるまでその結果はキャンセルされるか破棄される可能性がある。
キャンセルは、その命令より前の命令が例外を発生させたり、分岐予測ミスが発生した場合に起きる。
実行中の命令は基本的に投機的である。
命令の実行結果は、その命令が完了するまでは投機的な結果である。
その結果はリタイアされると初めて非投機的になり、リタイアの論理は、その命令が例外を発生させないことを決定するものである。

## 1.12 IFFRFの"Future File"セクション

アーキテクチャレジスタの2つ目のエントリには「未来の」値が格納されている。
これらのレジスタのうち16個はまとめてフューチャーファイル(Future File)と呼ばれている。
これらのエントリには、任意の命令により特定のアーキテクチャレジスタに格納された細心の値が格納されている。
Future Fileには、リタイアされた結果も、リタイア前の結果も含まれている。
フューチャーファイルの値はリタイアされていない命令も含んだ投機的なものである。
命令が正しく終了しリタイアすると、その値は非投機的になる。

![Implementing Precise Interrupts in Pipelined Processors](future-file.JPG)

実行中の命令の計算結果が生成されると、その値はすぐにフューチャーファイルに格納される。
しかしフューチャーファイルは特定のレジスタにおいて最新の値でないと受け入れない。
もし後続の命令が前の命令よりも前に結果を生成しフューチャーファイルに書き込んだならば、前の命令が完了してもその値はフューチャーファイルには書き込まれない。
終了した命令は、フューチャーファイルと命令コードのレジスタ番号(0から15のアーキテクチャレジスタ番号)との対応をとる。
結果が上書きされるかどうかは、「リオーダバッファタグ」を利用して決定される。
各フューチャーファイルのエントリは該当するタグに相当する。
ある命令はタグがマッチし、エントリを保持しているならば書き込みを行う。

